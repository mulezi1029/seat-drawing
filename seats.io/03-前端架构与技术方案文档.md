# Seats.io Designer - 前端架构与技术方案文档

## 目录

1. [架构概览](#1-架构概览)
2. [技术栈选择](#2-技术栈选择)
3. [核心架构设计](#3-核心架构设计)
4. [模块详细设计](#4-模块详细设计)
5. [渲染方案](#5-渲染方案)
6. [状态管理](#6-状态管理)
7. [性能优化](#7-性能优化)
8. [项目目录结构](#8-项目目录结构)
9. [关键实现细节](#9-关键实现细节)
10. [开发规范](#10-开发规范)

---

## 1. 架构概览

### 1.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           Presentation Layer                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐ │
│  │   Toolbar   │  │   Canvas    │  │ Properties  │  │    Layers       │ │
│  │   Component │  │  Component  │  │   Panel     │  │    Panel        │ │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └────────┬────────┘ │
└─────────┼────────────────┼────────────────┼──────────────────┼──────────┘
          │                │                │                  │
          └────────────────┴────────────────┴──────────────────┘
                                   │
                              ┌────┴────┐
                              │  Hooks  │
                              │  Layer  │
                              └────┬────┘
                                   │
          ┌────────────────────────┼────────────────────────┐
          │                        │                        │
     ┌────┴────┐             ┌────┴────┐            ┌─────┴─────┐
     │  Tool   │             │ Command │            │  Scene    │
     │ System  │             │ System  │            │  Graph    │
     └────┬────┘             └────┬────┘            └─────┬─────┘
          │                        │                        │
     ┌────┴────┐             ┌────┴────┐            ┌─────┴─────┐
     │   SVG   │             │  State  │            │  Spatial  │
     │Renderer │             │ History │            │   Index   │
     └─────────┘             └─────────┘            └───────────┘
```

### 1.2 架构原则

1. **单一职责**: 每个模块只负责单一功能领域
2. **可测试性**: 核心业务逻辑不依赖 UI 框架
3. **可扩展性**: 新功能通过插件/扩展方式添加
4. **性能优先**: 大数量级对象渲染优化
5. **类型安全**: TypeScript 全类型覆盖

---

## 2. 技术栈选择

### 2.1 核心技术


| 技术           | 版本   | 用途    |
| ------------ | ---- | ----- |
| React        | 18.x | UI 框架 |
| TypeScript   | 5.x  | 类型系统  |
| Vite         | 5.x  | 构建工具  |
| Tailwind CSS | 3.x  | 样式系统  |


### 2.2 UI 组件


| 技术           | 用途                            |
| ------------ | ----------------------------- |
| Radix UI     | 无头组件 (Dialog, Dropdown, etc.) |
| Lucide React | 图标库                           |
| shadcn/ui    | 基础组件库                         |


### 2.3 状态管理


| 技术          | 用途      |
| ----------- | ------- |
| React Hooks | 组件状态    |
| useReducer  | 复杂状态逻辑  |
| useContext  | 跨组件共享   |
| Refs        | 非渲染相关状态 |


### 2.4 工具库


| 技术       | 用途    |
| -------- | ----- |
| Zod      | 数据校验  |
| nanoid   | ID 生成 |
| date-fns | 日期处理  |


---

## 3. 核心架构设计

### 3.1 分层架构

```
┌─────────────────────────────────────────────────────────────┐
│  Presentation Layer (React Components)                      │
│  - App.tsx, Toolbar.tsx, Canvas.tsx, PropertiesPanel.tsx    │
├─────────────────────────────────────────────────────────────┤
│  Hooks Layer (Custom Hooks)                                 │
│  - useVenueDesigner.ts, useViewport.ts, useSelection.ts     │
├─────────────────────────────────────────────────────────────┤
│  Core Business Logic (Pure TypeScript)                      │
│  - ToolSystem, CommandSystem, SceneGraph, Geometry          │
├─────────────────────────────────────────────────────────────┤
│  Rendering Layer (SVG + Canvas)                             │
│  - SVGRenderer, OverlayRenderer                             │
├─────────────────────────────────────────────────────────────┤
│  Utilities                                                  │
│  - Geometry, SpatialIndex, EventBus                         │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 核心系统交互

```
User Input → Canvas Component → ToolManager → Tool.execute()
                                                   │
                                                   ▼
Command ← CommandManager.execute() ← Command.create()
   │
   ▼
SceneGraph.update() → State Update → React Re-render
```

---

## 4. 模块详细设计

### 4.1 Tool System (工具系统)

#### 4.1.1 架构设计

```typescript
// src/tools/types.ts
export interface Tool {
  id: string;
  name: string;
  icon: LucideIcon;
  cursor: string;

  // 生命周期
  onActivate(): void;
  onDeactivate(): void;

  // 鼠标事件
  onMouseDown(e: ToolEvent): void;
  onMouseMove(e: ToolEvent): void;
  onMouseUp(e: ToolEvent): void;
  onDoubleClick(e: ToolEvent): void;
  onWheel(e: WheelEvent): void;

  // 键盘事件
  onKeyDown(e: KeyboardEvent): void;
  onKeyUp(e: KeyboardEvent): void;
}

export interface ToolEvent {
  worldPoint: Point;
  screenPoint: Point;
  viewportPoint: Point;
  shiftKey: boolean;
  altKey: boolean;
  ctrlKey: boolean;
  button: number;
}
```

#### 4.1.2 ToolManager 实现

```typescript
// src/tools/ToolManager.ts
export class ToolManager {
  private tools: Map<string, Tool> = new Map();
  private currentTool: Tool | null = null;
  private context: ToolContext;

  constructor(context: ToolContext) {
    this.context = context;
    this.registerDefaultTools();
  }

  registerTool(tool: Tool): void {
    this.tools.set(tool.id, tool);
  }

  setTool(toolId: string): void {
    if (this.currentTool) {
      this.currentTool.onDeactivate();
    }

    this.currentTool = this.tools.get(toolId) || null;

    if (this.currentTool) {
      this.currentTool.onActivate();
      this.context.setCursor(this.currentTool.cursor);
    }
  }

  // 事件分发
  handleMouseDown(e: MouseEvent): void {
    if (!this.currentTool) return;

    const toolEvent = this.createToolEvent(e);
    this.currentTool.onMouseDown(toolEvent);
  }

  private createToolEvent(e: MouseEvent): ToolEvent {
    const rect = (e.target as HTMLElement).getBoundingClientRect();
    const viewportPoint = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };

    return {
      worldPoint: this.context.viewportToWorld(viewportPoint),
      screenPoint: { x: e.clientX, y: e.clientY },
      viewportPoint,
      shiftKey: e.shiftKey,
      altKey: e.altKey,
      ctrlKey: e.ctrlKey,
      button: e.button
    };
  }
}
```

#### 4.1.3 工具列表


| 工具              | ID           | 功能         |
| --------------- | ------------ | ---------- |
| ViewTool        | view         | 画布平移、缩放、选择 |
| DrawSectionTool | draw-section | 绘制座位区域     |
| DrawSeatTool    | draw-seat    | 绘制单个座位     |
| DrawRowTool     | draw-row     | 绘制座位行      |
| TextTool        | text         | 添加文本标注     |
| MeasureTool     | measure      | 测量距离       |


### 4.2 Command System (命令系统)

#### 4.2.1 架构设计

```typescript
// src/commands/types.ts
export interface Command {
  id: string;
  description: string;
  timestamp: number;

  execute(context: CommandContext): void;
  undo(context: CommandContext): void;
  redo?(context: CommandContext): void;
}

export interface CommandContext {
  venueMap: VenueMap;
  setVenueMap: (map: VenueMap) => void;

  // 辅助方法
  getSection(id: string): Section | undefined;
  getSeat(id: string): Seat | undefined;
  addSeat(seat: Seat): void;
  removeSeat(id: string): Seat | undefined;
}
```

#### 4.2.2 CommandManager 实现

```typescript
// src/commands/CommandManager.ts
export class CommandManager {
  private history: Command[] = [];
  private index: number = -1;
  private maxHistory: number = 50;
  private context: CommandContext;

  constructor(context: CommandContext) {
    this.context = context;
  }

  execute(command: Command): void {
    // 执行命令
    command.execute(this.context);

    // 如果有撤销历史，清除后面的历史
    if (this.index < this.history.length - 1) {
      this.history = this.history.slice(0, this.index + 1);
    }

    // 添加到历史
    this.history.push(command);
    this.index++;

    // 限制历史数量
    if (this.history.length > this.maxHistory) {
      this.history.shift();
      this.index--;
    }

    // 触发状态更新
    this.notifyChange();
  }

  undo(): void {
    if (this.index < 0) return;

    const command = this.history[this.index];
    command.undo(this.context);
    this.index--;

    this.notifyChange();
  }

  redo(): void {
    if (this.index >= this.history.length - 1) return;

    this.index++;
    const command = this.history[this.index];
    (command.redo || command.execute)(this.context);

    this.notifyChange();
  }

  canUndo(): boolean {
    return this.index >= 0;
  }

  canRedo(): boolean {
    return this.index < this.history.length - 1;
  }

  private notifyChange(): void {
    // 通知监听器状态变化
  }
}
```

### 4.3 Scene Graph (场景图)

#### 4.3.1 架构设计

```typescript
// src/scene/SceneGraph.ts
export class SceneGraph {
  private sections: Map<string, Section> = new Map();
  private seats: Map<string, Seat> = new Map();
  private spatialIndex: SpatialIndex;

  constructor() {
    this.spatialIndex = new SpatialIndex();
  }

  // Section 操作
  addSection(section: Section): void {
    this.sections.set(section.id, section);
    this.spatialIndex.insert(section);
  }

  removeSection(id: string): Section | null {
    const section = this.sections.get(id);
    if (section) {
      this.sections.delete(id);
      this.spatialIndex.remove(section);
    }
    return section || null;
  }

  updateSection(id: string, updates: Partial<Section>): void {
    const section = this.sections.get(id);
    if (section) {
      const updated = { ...section, ...updates };
      this.sections.set(id, updated);
      this.spatialIndex.update(updated);
    }
  }

  // Seat 操作
  addSeat(seat: Seat): void {
    this.seats.set(seat.id, seat);
    this.spatialIndex.insert(seat);
  }

  removeSeat(id: string): Seat | null {
    const seat = this.seats.get(id);
    if (seat) {
      this.seats.delete(id);
      this.spatialIndex.remove(seat);
    }
    return seat || null;
  }

  // Hit Testing
  hitTest(point: Point): HitResult {
    return this.spatialIndex.query(point);
  }

  getSectionAt(point: Point): Section | null {
    for (const section of this.sections.values()) {
      if (Geometry.pointInPolygon(point, section.points)) {
        return section;
      }
    }
    return null;
  }

  getSeatAt(point: Point, sectionId?: string): Seat | null {
    const seats = sectionId
      ? this.getSeatsBySection(sectionId)
      : Array.from(this.seats.values());

    for (const seat of seats) {
      const distance = Math.sqrt(
        Math.pow(seat.position.x - point.x, 2) +
        Math.pow(seat.position.y - point.y, 2)
      );
      if (distance <= SEAT_RADIUS) {
        return seat;
      }
    }
    return null;
  }

  getSeatsBySection(sectionId: string): Seat[] {
    return Array.from(this.seats.values())
      .filter(seat => seat.sectionId === sectionId);
  }
}
```

#### 4.3.2 Spatial Index (空间索引)

```typescript
// src/scene/SpatialIndex.ts
export class SpatialIndex {
  private grid: Map<string, Set<string>> = new Map();
  private cellSize: number = 100;
  private objectMap: Map<string, BoundingBox> = new Map();

  private getCellKey(x: number, y: number): string {
    const cellX = Math.floor(x / this.cellSize);
    const cellY = Math.floor(y / this.cellSize);
    return `${cellX},${cellY}`;
  }

  insert(obj: SpatialObject): void {
    const bbox = this.getBoundingBox(obj);
    this.objectMap.set(obj.id, bbox);

    // 计算覆盖的网格单元
    const minCellX = Math.floor(bbox.minX / this.cellSize);
    const maxCellX = Math.floor(bbox.maxX / this.cellSize);
    const minCellY = Math.floor(bbox.minY / this.cellSize);
    const maxCellY = Math.floor(bbox.maxY / this.cellSize);

    for (let x = minCellX; x <= maxCellX; x++) {
      for (let y = minCellY; y <= maxCellY; y++) {
        const key = `${x},${y}`;
        if (!this.grid.has(key)) {
          this.grid.set(key, new Set());
        }
        this.grid.get(key)!.add(obj.id);
      }
    }
  }

  query(point: Point): HitResult {
    const key = this.getCellKey(point.x, point.y);
    const objectIds = this.grid.get(key);

    if (!objectIds) return { hit: false };

    for (const id of objectIds) {
      const obj = this.getObject(id);
      if (obj && this.pointInObject(point, obj)) {
        return { hit: true, object: obj };
      }
    }

    return { hit: false };
  }
}
```

### 4.4 Coordinate System (坐标系统)

#### 4.4.1 三层坐标系

```
┌─────────────────────────────────────────────────────────────┐
│ Screen Coordinates                                          │
│ - 浏览器屏幕坐标系                                          │
│ - 原点在屏幕左上角                                          │
│ - 单位: CSS pixels                                          │
├─────────────────────────────────────────────────────────────┤
│ Viewport Coordinates                                        │
│ - 画布容器坐标系                                            │
│ - 原点在容器左上角                                          │
│ - 单位: CSS pixels                                          │
├─────────────────────────────────────────────────────────────┤
│ World Coordinates                                           │
│ - 业务逻辑坐标系                                            │
│ - 原点在世界中心 (0, 0)                                     │
│ - 范围: (-25000, -25000) ~ (25000, 25000)                   │
│ - 单位: 抽象单位                                            │
└─────────────────────────────────────────────────────────────┘
```

#### 4.4.2 坐标转换实现

```typescript
// src/utils/coordinates.ts
export interface ViewportState {
  scale: number;
  offsetX: number;
  offsetY: number;
}

export const CoordinateTransform = {
  // Viewport → World
  viewportToWorld(point: Point, viewport: ViewportState): Point {
    return {
      x: (point.x - viewport.offsetX) / viewport.scale,
      y: (point.y - viewport.offsetY) / viewport.scale
    };
  },

  // World → Viewport
  worldToViewport(point: Point, viewport: ViewportState): Point {
    return {
      x: point.x * viewport.scale + viewport.offsetX,
      y: point.y * viewport.scale + viewport.offsetY
    };
  },

  // Screen → Viewport
  screenToViewport(point: Point, container: HTMLElement): Point {
    const rect = container.getBoundingClientRect();
    return {
      x: point.x - rect.left,
      y: point.y - rect.top
    };
  },

  // 计算 SVG transform 属性
  getSVGTransform(viewport: ViewportState): string {
    return `translate(${viewport.offsetX}, ${viewport.offsetY}) scale(${viewport.scale})`;
  }
};
```

---

## 5. 渲染方案

### 5.1 SVG 渲染架构

```
<svg id="canvas">
  <!-- 背景层 (不随视口变换) -->
  <g id="background-layer">
    <pattern id="grid">...</pattern>
    <rect fill="url(#grid)">
    <image id="background-image">
  </g>

  <!-- 视口层 (应用 transform) -->
  <g id="viewport" transform="translate(x, y) scale(s)">
    <!-- 区域层 -->
    <g id="section-layer">
      <polygon class="section">
      <polygon class="section">
    </g>

    <!-- 座位层 -->
    <g id="seat-layer">
      <g class="seat">
      <g class="seat">
    </g>

    <!-- 标注层 -->
    <g id="annotation-layer">
      <text>
    </g>

    <!-- 交互层 -->
    <g id="interaction-layer">
      <rect class="selection-box">
    </g>
  </g>
</svg>
```

### 5.2 渲染优化策略

#### 5.2.1 虚拟化渲染

```typescript
// 只渲染视口内的对象
function getVisibleObjects(
  objects: SpatialObject[],
  viewport: ViewportState,
  containerSize: Size
): SpatialObject[] {
  const visibleBounds = {
    minX: -viewport.offsetX / viewport.scale,
    maxX: (containerSize.width - viewport.offsetX) / viewport.scale,
    minY: -viewport.offsetY / viewport.scale,
    maxY: (containerSize.height - viewport.offsetY) / viewport.scale
  };

  return objects.filter(obj =>
    intersects(getBoundingBox(obj), visibleBounds)
  );
}
```

#### 5.2.2 分层渲染


| 层级         | 渲染内容   | 更新频率 | 优化策略     |
| ---------- | ------ | ---- | -------- |
| Background | 网格、背景图 | 低    | 缓存为图片    |
| Section    | 区域多边形  | 中    | SVG 路径复用 |
| Seat       | 座位图形   | 高    | 简化为圆点    |
| Overlay    | 选中框、预览 | 极高   | 单独图层     |


#### 5.2.3 选择框渲染

```typescript
// 使用 vector-effect 保持线宽一致
<rect
  x={bbox.x}
  y={bbox.y}
  width={bbox.width}
  height={bbox.height}
  fill="none"
  stroke="#3b82f6"
  strokeWidth={2 / viewport.scale}  // 或者
  vectorEffect="non-scaling-stroke"  // 保持线宽不随缩放变化
/>
```

---

## 6. 状态管理

### 6.1 状态分层

```typescript
// 应用状态结构
interface AppState {
  // 持久化状态
  venueMap: VenueMap;
  categories: Category[];

  // 编辑器状态
  editor: {
    currentTool: string;
    viewport: ViewportState;
    mode: 'view' | 'section-edit';
    currentSectionId: string | null;
  };

  // 选择状态
  selection: {
    sectionId: string | null;
    seatIds: Set<string>;
  };

  // UI 状态
  ui: {
    showGrid: boolean;
    showLabels: boolean;
    sidebarOpen: boolean;
  };
}
```

### 6.2 状态更新流程

```
User Action → Tool.execute() → Command.execute() →
setVenueMap() → React Re-render → SVG Update
```

### 6.3 Hooks 设计

```typescript
// useVenueDesigner.ts - 主 Hook
export function useVenueDesigner() {
  const [venueMap, setVenueMap] = useState<VenueMap>(initialMap);
  const [editorState, setEditorState] = useState<EditorState>(initialEditor);
  const [selection, setSelection] = useState<Selection>(initialSelection);

  const viewport = useViewport();
  const commands = useCommands({ venueMap, setVenueMap });
  const toolManager = useToolManager({ ... });

  return {
    venueMap,
    editorState,
    selection,
    viewport,
    commands,
    toolManager,
    // actions
    enterSection,
    exitSection,
    selectSeat,
    clearSelection,
  };
}

// useViewport.ts - 视口管理
export function useViewport() {
  const [viewport, setViewport] = useState<ViewportState>({
    scale: 1,
    offsetX: 0,
    offsetY: 0
  });

  const zoomTo = useCallback((center: Point, scale: number) => {
    // 计算新的 offset
  }, []);

  const zoomToFit = useCallback((bounds: BoundingBox) => {
    // 计算适应边界的缩放和平移
  }, []);

  return {
    viewport,
    setViewport,
    zoomTo,
    zoomToFit,
    panTo
  };
}

// useSelection.ts - 选择管理
export function useSelection() {
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());

  const select = useCallback((id: string, multi: boolean = false) => {
    setSelectedIds(prev => {
      const next = multi ? new Set(prev) : new Set();
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  }, []);

  return {
    selectedIds,
    selectedArray: Array.from(selectedIds),
    select,
    selectAll,
    clear
  };
}
```

---

## 7. 性能优化

### 7.1 渲染优化


| 优化手段        | 实现方式                  | 效果            |
| ----------- | --------------------- | ------------- |
| 虚拟化         | 只渲染视口内对象              | 减少 80% DOM 节点 |
| 分层渲染        | 独立图层，局部更新             | 减少重绘区域        |
| 对象池         | 复用 SVG 元素             | 减少内存分配        |
| RAF 节流      | requestAnimationFrame | 流畅动画          |
| will-change | CSS 提示                | GPU 加速        |


### 7.2 大数据量优化

```typescript
// 1. 座位聚合显示
function shouldCluster(viewport: ViewportState): boolean {
  return viewport.scale < 0.3;  // 缩放较小时聚类
}

// 2. 简化渲染
function renderSeat(seat: Seat, viewport: ViewportState): JSX.Element {
  if (viewport.scale < 0.2) {
    // 极小比例：简化为小圆点
    return <circle r={2} />;
  }
  if (viewport.scale < 0.5) {
    // 小比例：不显示编号
    return <circle r={SEAT_RADIUS} />;
  }
  // 正常比例：完整渲染
  return (
    <g>
      <circle r={SEAT_RADIUS} />
      <text>{seat.label}</text>
    </g>
  );
}
```

### 7.3 内存优化

- 命令历史限制 (默认 50 条)
- 大对象使用 refs 而非 state
- 及时清理事件监听
- 使用 WeakMap 存储临时数据

---

## 8. 项目目录结构

```
src/
├── components/           # React 组件
│   ├── canvas/          # 画布相关
│   │   ├── Canvas.tsx
│   │   ├── SVGCanvas.tsx
│   │   ├── Seat.tsx
│   │   └── Section.tsx
│   ├── ui/              # UI 组件
│   │   ├── toolbar/
│   │   ├── panels/
│   │   └── common/
│   ├── Toolbar.tsx
│   ├── PropertiesPanel.tsx
│   └── LayersPanel.tsx
├── hooks/               # 自定义 Hooks
│   ├── useVenueDesigner.ts
│   ├── useViewport.ts
│   ├── useSelection.ts
│   ├── useCommands.ts
│   └── useDrawing.ts
├── tools/               # 工具系统
│   ├── types.ts
│   ├── ToolManager.ts
│   ├── ViewTool.ts
│   ├── DrawSectionTool.ts
│   ├── DrawSeatTool.ts
│   └── MoveTool.ts
├── commands/            # 命令系统
│   ├── types.ts
│   ├── CommandManager.ts
│   ├── CreateSectionCommand.ts
│   ├── MoveSectionCommand.ts
│   ├── CreateSeatCommand.ts
│   └── MoveSeatsCommand.ts
├── scene/               # 场景图
│   ├── SceneGraph.ts
│   └── SpatialIndex.ts
├── render/              # 渲染层
│   ├── Renderer.ts
│   ├── SVGRenderer.ts
│   └── OverlayRenderer.ts
├── utils/               # 工具函数
│   ├── geometry.ts
│   ├── coordinates.ts
│   └── id.ts
├── types/               # 类型定义
│   └── index.ts
├── constants/           # 常量
│   └── index.ts
└── styles/              # 样式
    └── globals.css
```

---

## 9. 关键实现细节

### 9.1 拖拽移动实现

```typescript
// ViewTool.ts
class ViewTool extends BaseTool {
  private dragState: {
    startPoint: Point;
    currentPoint: Point;
    sectionId: string;
  } | null = null;

  onMouseDown(e: ToolEvent): void {
    const section = this.context.getSectionAtPoint(e.worldPoint);
    if (section && this.context.selectedSectionId === section.id) {
      this.dragState = {
        startPoint: e.worldPoint,
        currentPoint: e.worldPoint,
        sectionId: section.id
      };
    }
  }

  onMouseMove(e: ToolEvent): void {
    if (!this.dragState) return;

    this.dragState.currentPoint = e.worldPoint;

    // 渲染拖拽预览
    const dx = this.dragState.currentPoint.x - this.dragState.startPoint.x;
    const dy = this.dragState.currentPoint.y - this.dragState.startPoint.y;

    this.context.setToolOverlay(
      this.renderDragPreview(dx, dy)
    );
  }

  onMouseUp(e: ToolEvent): void {
    if (!this.dragState) return;

    const dx = e.worldPoint.x - this.dragState.startPoint.x;
    const dy = e.worldPoint.y - this.dragState.startPoint.y;

    // 执行移动命令
    if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
      const command = new MoveSectionCommand(
        this.dragState.sectionId,
        dx,
        dy
      );
      this.context.execute(command);
    }

    this.dragState = null;
    this.context.setToolOverlay(null);
  }
}
```

### 9.2 Focus Mode 实现

```typescript
// useVenueDesigner.ts
function useVenueDesigner() {
  const previousViewportRef = useRef<ViewportState | null>(null);

  const enterSection = useCallback((sectionId: string) => {
    // 保存当前视图状态
    previousViewportRef.current = { ...viewport };

    // 计算区域边界
    const section = venueMap.sections.find(s => s.id === sectionId);
    if (!section) return;

    const bounds = Geometry.getBoundingBox(section.points);

    // 自动缩放到区域
    const newViewport = calculateViewportToFit(bounds, containerSize);
    setViewport(newViewport);

    // 设置编辑模式
    setEditorState(prev => ({
      ...prev,
      mode: 'section-edit',
      currentSectionId: sectionId
    }));

    // 淡化其他区域
    selection.setSelectedSectionId(sectionId);
  }, []);

  const exitSection = useCallback(() => {
    // 恢复原始视图
    if (previousViewportRef.current) {
      setViewport(previousViewportRef.current);
      previousViewportRef.current = null;
    }

    // 退出编辑模式
    setEditorState(prev => ({
      ...prev,
      mode: 'view',
      currentSectionId: null
    }));

    selection.clearSelection();
  }, []);
}
```

### 9.3 座位重叠检测

```typescript
// geometry.ts
export function checkSeatOverlap(
  seat: Seat,
  existingSeats: Seat[],
  minDistance: number = SEAT_RADIUS * 2
): boolean {
  for (const other of existingSeats) {
    const distance = Math.sqrt(
      Math.pow(seat.position.x - other.position.x, 2) +
      Math.pow(seat.position.y - other.position.y, 2)
    );

    if (distance < minDistance) {
      return true;
    }
  }

  return false;
}
```

---

## 10. 开发规范

### 10.1 命名规范


| 类型    | 命名规范                          | 示例                                  |
| ----- | ----------------------------- | ----------------------------------- |
| 组件    | PascalCase                    | `Canvas.tsx`, `Toolbar.tsx`         |
| Hooks | camelCase with use prefix     | `useViewport.ts`, `useSelection.ts` |
| 类     | PascalCase                    | `ToolManager`, `CommandManager`     |
| 接口    | PascalCase with I prefix (可选) | `ITool`, `Command`                  |
| 常量    | UPPER_SNAKE_CASE              | `MAX_HISTORY`, `SEAT_RADIUS`        |
| 枚举    | PascalCase                    | `ToolType`, `SeatStatus`            |


### 10.2 文件组织

- 每个类/组件独立文件
- 相关文件放在同一目录
- 测试文件与源文件同级

### 10.3 代码风格

- 使用 TypeScript strict 模式
- 函数最大 50 行
- 组件最大 200 行
- 优先使用 const/let，避免 var
- 使用可选链 `?.` 和空值合并 `??`

### 10.4 注释规范

```typescript
/**
 * 计算视口缩放以适应边界框
 *
 * @param bounds - 边界框
 * @param containerSize - 容器大小
 * @param padding - 边距 (默认 20)
 * @returns 新的视口状态
 *
 * @example
 * const viewport = calculateViewportToFit(bounds, { width: 800, height: 600 });
 */
function calculateViewportToFit(
  bounds: BoundingBox,
  containerSize: Size,
  padding: number = 20
): ViewportState {
  // 实现...
}
```

---

## 附录：参考资源

1. **SVG 规范**: [https://www.w3.org/TR/SVG2/](https://www.w3.org/TR/SVG2/)
2. **React 文档**: [https://react.dev/](https://react.dev/)
3. **TypeScript 文档**: [https://www.typescriptlang.org/docs/](https://www.typescriptlang.org/docs/)
4. **seats.io API**: [https://docs.seats.io/](https://docs.seats.io/)

