# Select Tool Implementation - 选择工具实现方案

## 一、概述

### 1.1 功能范围

本方案实现完整的选择工具功能，包括：


| 功能模块  | 描述                      | 状态     |
| ----- | ----------------------- | ------ |
| 基础选择  | 单击选中、Ctrl+多选、框选         | ✅ 已实现  |
| 视觉反馈  | 选中高亮、控制点、边界框            | ✅ 已实现  |
| 交互增强  | 悬停高亮、光标变化               | ✅ 已实现  |
| 拖拽移动  | 拖拽选中元素移动位置              | ✅ 已实现  |
| 旋转功能  | 旋转手柄拖动旋转选中元素            | ✅ 已实现  |
| 多选边界框 | 多选时显示整体边界框              | ✅ 已实现  |
| 复制功能  | Ctrl+C/D 复制选中元素         | ✅ 已实现  |
| 删除功能  | Delete/Backspace 删除选中元素 | ✅ 已实现  |
| 拖拽辅助线 | 拖拽时显示中心十字线和边界辅助线    | ✅ 已实现  |


### 1.2 交互总览

```
┌─────────────────────────────────────────────────────────────────┐
│                        选择工具交互流程                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 鼠标左键按下                                             │   │
│  │   ↓                                                     │   │
│  │ ┌─────────────────┐    ┌─────────────────┐             │   │
│  │ │ 点击元素?       │──否→│ 点击空白处      │             │   │
│  │ │   ↓ 是          │    │   ↓             │             │   │
│  │ │ 已选中?         │    │ 开始框选        │             │   │
│  │ │   ↓ 是          │    │   ↓             │             │   │
│  │ │ 开始拖拽        │    │ 鼠标释放        │             │   │
│  │ │   ↓             │    │   ↓             │             │   │
│  │ │ 多选?           │    │ 框选元素        │             │   │
│  │ │   ↓ 否          │    └─────────────────┘             │   │
│  │ │ 单选该元素      │                                    │   │
│  │ └─────────────────┘                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  快捷键:                                                        │
│   - Ctrl+A: 全选                                               │
│   - Delete/Backspace: 删除选中元素                              │
│   - ESC: 取消选择                                              │
│   - Ctrl+点击: 多选/取消选择                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 二、核心类型定义

```typescript
// app/src/types/index.ts

/**
 * 选择框状态
 */
export interface SelectionBox {
  start: Point;
  end: Point;
  isSelecting: boolean;
}

/**
 * 边界框
 */
export interface BoundingBox {
  minX: number;
  minY: number;
  maxX: number;
  maxY: number;
}
```

---

## 三、核心算法

### 3.1 点包含检测 (Point-in-Polygon)

使用射线法判断点是否在多边形内：

```typescript
// app/src/utils/selection.ts

export function isPointInPolygon(point: Point, polygon: Point[]): boolean {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x, yi = polygon[i].y;
    const xj = polygon[j].x, yj = polygon[j].y;

    const intersect = ((yi > point.y) !== (yj > point.y))
        && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}
```

### 3.2 边界框计算

```typescript
export function getBoundingBox(points: Point[]): BoundingBox {
  const xs = points.map(p => p.x);
  const ys = points.map(p => p.y);
  return {
    minX: Math.min(...xs),
    minY: Math.min(...ys),
    maxX: Math.max(...xs),
    maxY: Math.max(...ys),
  };
}
```

### 3.3 框选检测

```typescript
export function doBoundingBoxesIntersect(
  box1: BoundingBox,
  box2: BoundingBox
): boolean {
  return !(box1.maxX < box2.minX ||
           box1.minX > box2.maxX ||
           box1.maxY < box2.minY ||
           box1.minY > box2.maxY);
}

export function createSelectionBox(start: Point, end: Point): BoundingBox {
  return {
    minX: Math.min(start.x, end.x),
    maxX: Math.max(start.x, end.x),
    minY: Math.min(start.y, end.y),
    maxY: Math.max(start.y, end.y),
  };
}
```

---

## 四、组件实现

### 4.1 渲染层次结构

```
SVG (world-layer)
├── Background Layer          # 背景图
├── Grid Layer                # 网格
├── Sections Layer            # 区域多边形
├── Hover Highlight Layer     # 悬停高亮
├── Drag Guide Layer          # 拖拽辅助线 (拖拽时显示)
├── Bounding Box Layer        # 边界框和旋转手柄
├── Drawing Preview Layer     # 绘制预览
├── Guide Lines Layer         # 辅助线
├── Selection Box Layer       # 框选矩形
└── Cursor Guides             # 光标辅助线
```

### 4.2 SVGRenderer 组件

#### 4.2.1 边界框图层 (BoundingBoxLayer)

显示选中元素的边界框和旋转手柄，支持旋转过程中边界框跟随旋转：

```tsx
const BoundingBoxLayer: React.FC<{
  sections: Section[];
  selectedIds: Set<string>;
  scale: number;
  isRotating?: boolean;
  rotationAngle?: number;
  initialRotationBbox?: BoundingBox | null;
}> = ({ sections, selectedIds, scale, isRotating, rotationAngle, initialRotationBbox }) => {
  const selectedSections = sections.filter((s) => selectedIds.has(s.id));
  if (selectedSections.length === 0) return null;

  // 计算边界框：旋转中使用初始边界框，非旋转使用当前边界框
  const bboxes = selectedSections.map(s => getBoundingBox(s.points));
  const currentBbox = getCombinedBoundingBox(bboxes);
  const displayBbox = (isRotating && initialRotationBbox) ? initialRotationBbox : currentBbox;

  const width = displayBbox.maxX - displayBbox.minX;
  const height = displayBbox.maxY - displayBbox.minY;
  const centerX = (displayBbox.minX + displayBbox.maxX) / 2;
  const centerY = (displayBbox.minY + displayBbox.maxY) / 2;
  const handleY = displayBbox.minY - 20 / scale;

  return (
    <g className="bounding-box-layer" style={{ pointerEvents: 'none' }}>
      {isRotating ? (
        // 旋转状态：边界框和手柄跟随旋转
        <g transform={`rotate(${rotationAngle}, ${centerX}, ${centerY})`}>
          <rect
            x={displayBbox.minX}
            y={displayBbox.minY}
            width={width}
            height={height}
            fill="none"
            stroke="#3b82f6"
            strokeWidth={1 / scale}
            strokeDasharray={`${4 / scale},${2 / scale}`}
            opacity={0.8}
          />
          <line x1={centerX} y1={displayBbox.minY} x2={centerX} y2={handleY}
            stroke="#3b82f6" strokeWidth={1 / scale} />
          <circle cx={centerX} cy={handleY} r={6 / scale}
            fill="#3b82f6" stroke="white" strokeWidth={2 / scale}
            style={{ pointerEvents: 'auto', cursor: 'grabbing' }} />
          <text x={centerX} y={handleY - 15 / scale} textAnchor="middle"
            fontSize={12 / scale} fill="#3b82f6" fontWeight="bold">
            {Math.round(rotationAngle)}°
          </text>
        </g>
      ) : (
        // 非旋转状态：正常显示
        <>
          <rect x={displayBbox.minX} y={displayBbox.minY} width={width} height={height}
            fill="none" stroke="#3b82f6" strokeWidth={1 / scale}
            strokeDasharray={`${4 / scale},${2 / scale}`} />
          <line x1={centerX} y1={displayBbox.minY} x2={centerX} y2={handleY}
            stroke="#3b82f6" strokeWidth={1 / scale} />
          <circle cx={centerX} cy={handleY} r={6 / scale}
            fill="#3b82f6" stroke="white" strokeWidth={2 / scale}
            style={{ pointerEvents: 'auto', cursor: 'grab' }} />
        </>
      )}

      {/* 旋转指示（固定不旋转） */}
      {isRotating && (
        <>
          <circle cx={centerX} cy={centerY}
            r={Math.max(width, height) / 2 + 30 / scale}
            fill="none" stroke="#3b82f6" strokeWidth={1 / scale}
            strokeDasharray={`${2 / scale},${4 / scale}`} opacity={0.5} />
          <circle cx={centerX} cy={centerY} r={4 / scale}
            fill="#3b82f6" stroke="white" strokeWidth={2 / scale} />
        </>
      )}
    </g>
  );
};
```

#### 4.2.2 拖拽辅助线图层 (DragGuideLayer)

在拖拽选中元素时显示中心十字线和边界辅助线，帮助用户对齐元素：

```tsx
const DragGuideLayer: React.FC<{
  sections: Section[];
  selectedIds: Set<string>;
  scale: number;
  isDragging: boolean;
}> = ({ sections, selectedIds, scale, isDragging }) => {
  if (!isDragging || selectedIds.size === 0) return null;

  const selectedSections = sections.filter((s) => selectedIds.has(s.id));
  if (selectedSections.length === 0) return null;

  // 计算所有选中元素的整体边界框
  const bboxes = selectedSections.map(s => getBoundingBox(s.points));
  const combinedBbox = getCombinedBoundingBox(bboxes);
  if (!combinedBbox) return null;

  const { minX, maxX, minY, maxY } = combinedBbox;
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  const lineLength = 10000; // 辅助线延伸长度（足够覆盖画布）

  return (
    <g className="drag-guide-layer" style={{ pointerEvents: 'none' }}>
      {/* 中心水平辅助线 -  amber 色，较粗，高透明度 */}
      <line
        x1={centerX - lineLength} y1={centerY}
        x2={centerX + lineLength} y2={centerY}
        stroke="#f59e0b" strokeWidth={1 / scale}
        strokeDasharray={`${4 / scale},${2 / scale}`}
        opacity={0.8}
      />

      {/* 中心垂直辅助线 */}
      <line
        x1={centerX} y1={centerY - lineLength}
        x2={centerX} y2={centerY + lineLength}
        stroke="#f59e0b" strokeWidth={1 / scale}
        strokeDasharray={`${4 / scale},${2 / scale}`}
        opacity={0.8}
      />

      {/* 边界辅助线 - 顶部（较细，低透明度） */}
      <line x1={minX - lineLength} y1={minY} x2={minX + lineLength} y2={minY}
        stroke="#f59e0b" strokeWidth={0.5 / scale}
        strokeDasharray={`${2 / scale},${2 / scale}`} opacity={0.6} />

      {/* 边界辅助线 - 底部、左侧、右侧... */}
      {/* ... */}

      {/* 中心点标记 */}
      <circle
        cx={centerX} cy={centerY} r={4 / scale}
        fill="#f59e0b" stroke="white" strokeWidth={1 / scale}
      />
    </g>
  );
};
```

**视觉样式**：
- 中心辅助线：琥珀色 (`#f59e0b`)，线宽 `1/scale`，透明度 0.8
- 边界辅助线：琥珀色，线宽 `0.5/scale`，透明度 0.6（更淡）
- 中心点标记：圆形，填充琥珀色，白色描边
- 虚线样式：`4,2` 间隔（中心），`2,2` 间隔（边界）

#### 4.2.3 悬停高亮图层 (HoverHighlightLayer)

```tsx
const HoverHighlightLayer: React.FC<{
  sections: Section[];
  hoverElementId: string | null;
  scale: number;
}> = ({ sections, hoverElementId, scale }) => {
  if (!hoverElementId) return null;

  const hoverSection = sections.find((s) => s.id === hoverElementId);
  if (!hoverSection) return null;

  return (
    <g className="hover-highlight-layer" style={{ pointerEvents: 'none' }}>
      <polygon
        points={hoverSection.points.map((p) => `${p.x},${p.y}`).join(' ')}
        fill="none"
        stroke="#60a5fa"
        strokeWidth={2 / scale}
        strokeDasharray={`${3 / scale},${3 / scale}`}
        opacity={0.7}
      />
    </g>
  );
};
```

#### 4.2.4 选择框图层 (SelectionBoxLayer)

```tsx
const SelectionBoxLayer: React.FC<{
  boxStart: Point | null;
  boxEnd: Point | null;
  scale: number;
}> = ({ boxStart, boxEnd, scale }) => {
  if (!boxStart || !boxEnd) return null;

  const minX = Math.min(boxStart.x, boxEnd.x);
  const maxX = Math.max(boxStart.x, boxEnd.x);
  const minY = Math.min(boxStart.y, boxEnd.y);
  const maxY = Math.max(boxStart.y, boxEnd.y);

  return (
    <g className="selection-box-layer">
      <rect
        x={minX}
        y={minY}
        width={maxX - minX}
        height={maxY - minY}
        fill="rgba(59, 130, 246, 0.1)"
        stroke="#3b82f6"
        strokeWidth={1 / scale}
        strokeDasharray={`${4 / scale},${4 / scale}`}
      />
    </g>
  );
};
```

#### 4.2.5 选中控制点 (SelectionHandles)

```tsx
const SelectionHandles: React.FC<{
  section: Section;
  scale: number;
}> = ({ section, scale }) => {
  const handleRadius = 6 / scale;

  return (
    <g className="selection-handles">
      {section.points.map((point, index) => (
        <circle
          key={index}
          cx={point.x}
          cy={point.y}
          r={handleRadius}
          fill="white"
          stroke="#3b82f6"
          strokeWidth={2 / scale}
        />
      ))}
    </g>
  );
};
```

### 4.3 Canvas 事件处理

#### 4.3.1 状态定义

```typescript
// 选择状态
const [internalSelectedIds, setInternalSelectedIds] = useState<Set<string>>(new Set());
const selectedIds = externalSelectedIds ?? internalSelectedIds;

// 框选状态
const isBoxSelectingRef = useRef(false);
const boxStartRef = useRef<Point | null>(null);
const boxEndRef = useRef<Point | null>(null);

// 拖拽状态
const isDraggingElementRef = useRef(false);  // ref 用于快速检测
const [isDraggingElement, setIsDraggingElement] = useState(false);  // state 用于触发渲染
const dragStartPointRef = useRef<Point | null>(null);
const dragElementIdsRef = useRef<Set<string>>(new Set());

// 悬停状态
const [hoverElementId, setHoverElementId] = useState<string | null>(null);

// 旋转状态
const isRotatingRef = useRef(false);
const rotationCenterRef = useRef<Point | null>(null);
const rotationStartAngleRef = useRef<number>(0);
const rotationCurrentAngleRef = useRef<number>(0);
const rotationElementIdsRef = useRef<Set<string>>(new Set());
const [isHoveringRotationHandle, setIsHoveringRotationHandle] = useState(false);
const [rotationAngle, setRotationAngle] = useState<number>(0);
const [isRotating, setIsRotating] = useState(false);
const [initialRotationBbox, setInitialRotationBbox] = useState<BoundingBox | null>(null);
const originalSectionsRef = useRef<Section[]>([]);  // 保存原始数据避免累积旋转
```

**注意：拖拽状态的双重管理**

`isDraggingElement` 使用 ref + state 的双重管理模式：
- `isDraggingElementRef`: 用于事件处理中的快速状态检测（不触发重渲染）
- `isDraggingElement` (state): 用于传递给子组件触发 DragGuideLayer 渲染

```typescript
// 开始拖拽时同时更新 ref 和 state
isDraggingElementRef.current = true;
setIsDraggingElement(true);

// 结束拖拽时同样更新两者
isDraggingElementRef.current = false;
setIsDraggingElement(false);
```

#### 4.3.2 光标样式管理

```typescript
useEffect(() => {
  if (isPanningRef.current) {
    setCursorStyle('grabbing');
  } else if (isDraggingElementRef.current) {
    setCursorStyle('grabbing');
  } else if (isSpacePressed || isHandToolActive) {
    setCursorStyle('grab');
  } else if (activeTool === 'section' || activeTool === 'polygon') {
    setCursorStyle('crosshair');
  } else if (activeTool === 'select') {
    if (isBoxSelectingRef.current) {
      setCursorStyle('crosshair');
    } else if (hoverElementId && selectedIds.has(hoverElementId)) {
      setCursorStyle('grab');      // 已选中元素
    } else if (hoverElementId) {
      setCursorStyle('move');      // 可选元素
    } else {
      setCursorStyle('default');
    }
  } else {
    setCursorStyle('default');
  }
}, [isSpacePressed, isHandToolActive, activeTool, hoverElementId, selectedIds]);
```

#### 4.3.3 鼠标按下 (MouseDown)

```typescript
const handleMouseDown = useCallback((e: React.MouseEvent) => {
  e.preventDefault();

  // 平移优先级最高
  if (shouldPan(e)) {
    isPanningRef.current = true;
    panStartRef.current = { x: e.clientX, y: e.clientY };
    setCursorStyle('grabbing');
    return;
  }

  // 选择工具模式
  if (activeTool === 'select') {
    if (!containerRef.current) return;

    const containerRect = containerRef.current.getBoundingClientRect();
    const worldPoint = screenToWorld(
      e.clientX, e.clientY, containerRect, offsetX, offsetY, scale
    );

    // 检测点击的元素
    const clickedId = findElementAtPoint(worldPoint, sections);

    if (clickedId) {
      if (selectedIds.has(clickedId)) {
        // 点击已选中元素 - 开始拖拽
        isDraggingElementRef.current = true;
        dragStartPointRef.current = worldPoint;
        dragElementIdsRef.current = new Set(selectedIds);
        return;
      } else {
        // 点击未选中元素
        if (e.ctrlKey || e.metaKey) {
          setSelectedIds(prev => {
            const newSet = new Set(prev);
            newSet.add(clickedId);
            return newSet;
          });
        } else {
          setSelectedIds(new Set([clickedId]));
        }
        // 开始拖拽新选中的元素
        isDraggingElementRef.current = true;
        dragStartPointRef.current = worldPoint;
        dragElementIdsRef.current = new Set([clickedId]);
        return;
      }
    }

    // 点击空白处 - 开始框选
    boxStartRef.current = worldPoint;
    boxEndRef.current = worldPoint;
    isBoxSelectingRef.current = true;

    // 如果不是 Ctrl/Cmd 多选模式，清空当前选择
    if (!e.ctrlKey && !e.metaKey) {
      setSelectedIds(new Set());
    }
  }
}, [/* deps */]);
```

#### 4.3.4 鼠标移动 (MouseMove)

```typescript
const handleMouseMove = useCallback((e: React.MouseEvent) => {
  // 平移处理
  if (isPanningRef.current && panStartRef.current) {
    // ... 平移逻辑
    return;
  }

  if (!containerRef.current) return;
  const containerRect = containerRef.current.getBoundingClientRect();
  const worldPoint = screenToWorld(e.clientX, e.clientY, containerRect, offsetX, offsetY, scale);

  // 旋转中 - 更新角度（使用原始数据避免累积误差）
  if (isRotatingRef.current && rotationCenterRef.current) {
    const currentAngle = getAngle(rotationCenterRef.current, worldPoint);
    const deltaAngle = currentAngle - rotationStartAngleRef.current;
    rotationCurrentAngleRef.current = deltaAngle;
    setRotationAngle(deltaAngle);

    // 使用原始 section 数据进行旋转，避免累积误差
    onElementsRotate?.(
      rotationElementIdsRef.current,
      rotationCenterRef.current,
      deltaAngle,
      originalSectionsRef.current // 传入原始数据
    );
    return;
  }

  // 元素拖拽中 - 更新位置
  if (isDraggingElementRef.current && dragStartPointRef.current) {
    const dx = worldPoint.x - dragStartPointRef.current.x;
    const dy = worldPoint.y - dragStartPointRef.current.y;

    onElementsMove?.(dragElementIdsRef.current, dx, dy);
    dragStartPointRef.current = worldPoint;
    return;
  }

  // 选择工具框选更新
  if (activeTool === 'select' && isBoxSelectingRef.current && boxStartRef.current) {
    boxEndRef.current = worldPoint;
    onSelectionBoxChange?.(boxStartRef.current, worldPoint);
    return;
  }

  // 选择工具：检测悬停元素
  if (activeTool === 'select' && !isBoxSelectingRef.current && !isRotatingRef.current) {
    const hoveredId = findElementAtPoint(worldPoint, sections);
    if (hoveredId !== hoverElementId) {
      setHoverElementId(hoveredId);
    }
  }
}, [/* deps */]);
```

#### 4.3.5 旋转手柄交互

```typescript
// 检测点击旋转手柄
const isClickOnRotationHandle = (worldPoint: Point, bbox: BoundingBox): boolean => {
  const centerX = (bbox.minX + bbox.maxX) / 2;
  const handleY = bbox.minY - 20 / scale; // 手柄在边界框上方 20px
  const handleRadius = 10 / scale; // 点击容差

  const dx = worldPoint.x - centerX;
  const dy = worldPoint.y - handleY;
  return Math.sqrt(dx * dx + dy * dy) <= handleRadius;
};

// 在 MouseDown 中检测旋转手柄点击
if (selectedSections.length > 0 && !isBoxSelectingRef.current) {
  const bboxes = selectedSections.map(s => getBoundingBox(s.points));
  const combinedBbox = getCombinedBoundingBox(bboxes);

  if (isClickOnRotationHandle(worldPoint, combinedBbox)) {
    // 开始旋转
    const center = getBoundingBoxCenter(combinedBbox);
    isRotatingRef.current = true;
    rotationCenterRef.current = center;
    rotationStartAngleRef.current = getAngle(center, worldPoint);
    rotationCurrentAngleRef.current = 0;
    rotationElementIdsRef.current = new Set(selectedIds);
    setIsRotating(true);
    setRotationAngle(0);
    setInitialRotationBbox(combinedBbox);

    // 保存原始 section 数据，避免累积旋转误差
    originalSectionsRef.current = sections.filter(s => selectedIds.has(s.id));
    return;
  }
}
```

#### 4.3.5 鼠标释放 (MouseUp)

```typescript
const handleMouseUp = useCallback(() => {
  // 平移结束
  if (isPanningRef.current) {
    isPanningRef.current = false;
    // ... 恢复光标
  }

  // 元素拖拽结束
  if (isDraggingElementRef.current) {
    isDraggingElementRef.current = false;
    dragStartPointRef.current = null;
    dragElementIdsRef.current = new Set();
    onElementsMoveEnd?.();
  }

  // 选择工具完成选择
  if (activeTool === 'select' && isBoxSelectingRef.current) {
    if (boxStartRef.current && boxEndRef.current) {
      const selectionBox = createSelectionBox(boxStartRef.current, boxEndRef.current);

      // 框选：找到与选择框相交的元素
      const selected = findElementsInBox(selectionBox, sections);
      setSelectedIds(prev => {
        const newSet = new Set(prev);
        selected.forEach(id => newSet.add(id));
        return newSet;
      });
    }

    isBoxSelectingRef.current = false;
    boxStartRef.current = null;
    boxEndRef.current = null;
    onSelectionBoxChange?.(null, null);
  }
}, [/* deps */]);
```

### 4.4 App.tsx 状态管理

```typescript
/**
 * 处理元素移动 - 实时预览
 */
const handleElementsMove = useCallback((ids: Set<string>, dx: number, dy: number) => {
  if (ids.size === 0) return;

  setSections(prev => prev.map(section => {
    if (!ids.has(section.id)) return section;

    return {
      ...section,
      points: section.points.map(p => ({
        x: p.x + dx,
        y: p.y + dy,
      })),
    };
  }));
}, []);

/**
 * 处理元素移动结束
 */
const handleElementsMoveEnd = useCallback(() => {
  // 可在此添加撤销历史记录
  console.log('Elements move ended');
}, []);

/**
 * 处理元素旋转 - 实时预览
 * @param originalSections 旋转开始时的原始 section 数据，用于避免累积旋转误差
 */
const handleElementsRotate = useCallback((
  ids: Set<string>,
  center: Point,
  angle: number,
  originalSections?: Section[]
) => {
  if (ids.size === 0) return;

  setSections(prev => prev.map(section => {
    if (!ids.has(section.id)) return section;

    // 使用原始 section 数据进行旋转，避免累积旋转错误
    const sourceSection = originalSections?.find(s => s.id === section.id) || section;

    return {
      ...section,
      points: rotatePolygon(sourceSection.points, center, angle),
    };
  }));
}, []);

/**
 * 处理元素旋转结束
 */
const handleElementsRotateEnd = useCallback(() => {
  // 可在此添加撤销历史记录
  console.log('Elements rotate ended');
}, []);
```

---

## 五、文件修改清单


| 文件                                          | 修改内容                                                                         |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| `app/src/types/index.ts`                    | 添加 `SelectionBox`, `BoundingBox` 类型定义                                        |
| `app/src/utils/selection.ts`                | 新增：点包含检测、边界框计算、框选检测算法                                                        |
| `app/src/utils/coordinate.ts`               | 新增：`getAngle()`, `rotatePoint()`, `rotatePolygon()` 旋转工具函数                   |
| `app/src/components/canvas/Canvas.tsx`      | 添加选择工具事件处理、拖拽逻辑、光标管理、旋转交互；移除重复的 Delete 键盘处理，避免与 App.tsx 冲突 |
| `app/src/components/canvas/SVGRenderer.tsx` | 添加 `BoundingBoxLayer`, `DragGuideLayer`, `HoverHighlightLayer`, `SelectionBoxLayer` 组件，支持旋转可视化和拖拽辅助线 |
| `app/src/App.tsx`                           | 添加选择状态管理、元素移动处理、元素旋转处理、复制功能（Ctrl+C/D）、删除功能修复               |


---

## 六、验证清单

### 6.1 基础选择功能

- 单击选中：点击区域，该区域高亮
- 单击取消：点击已选中区域，取消选中
- 空白处点击：点击空白处，取消所有选择
- Ctrl+点击：多选/取消选择单个元素
- 框选：拖拽绘制选择框，框内元素被选中
- Ctrl+框选：添加到当前选择

### 6.2 视觉反馈

- 选中高亮：选中区域显示蓝色边框 (`#3b82f6`)
- 控制点：选中区域顶点显示白色控制点
- 多选指示：多个选中元素都显示高亮
- 选择框视觉：显示半透明蓝色矩形带虚线边框
- 边界框：显示选中元素的矩形边界框（虚线蓝色）
- 旋转手柄：顶部中心显示蓝色圆点手柄
- 悬停高亮：鼠标悬停时显示虚线轮廓

### 6.3 光标状态

- 默认状态：`default`
- 悬停可选元素：`move`
- 悬停已选中元素：`grab`
- 拖拽中：`grabbing`
- 框选模式：`crosshair`
- 旋转手柄：`crosshair`

### 6.4 拖拽移动

- 拖拽移动：点击并拖拽可移动选中元素
- 多元素拖拽：多选时可一起移动所有选中元素
- 实时预览：拖拽时实时更新位置
- 移动结束：释放鼠标完成移动

### 6.5 旋转功能

- 旋转手柄：选中元素显示旋转手柄（蓝色圆点）
- 整体边界框：多选时显示所有选中元素的整体边界框
- 手柄悬停：鼠标悬停旋转手柄时光标变为 `grab`
- 旋转操作：按住旋转手柄拖动可旋转选中元素
- 角度指示：旋转时显示当前旋转角度
- 多元素旋转：多选时所有选中元素围绕整体中心一起旋转
- 实时预览：旋转时实时更新元素位置
- **边界框跟随旋转**：旋转过程中边界框和手柄跟随元素一起旋转
- **避免累积误差**：使用原始坐标数据进行旋转，避免多次旋转后变形

### 6.6 键盘快捷键

- [x] Ctrl+A：全选所有区域
- [x] Delete/Backspace：删除选中区域
- [x] ESC：取消选择
- [x] Ctrl+C/D：复制选中元素

### 6.7 复制功能

- [x] Ctrl+C 复制：选中元素后按 Ctrl+C 可复制
- [x] Ctrl+D 复制：选中元素后按 Ctrl+D 也可复制
- [x] 位置偏移：复制的元素向右下方偏移 20px
- [x] 新 ID 生成：复制元素拥有新的唯一 ID
- [x] 名称标识：复制元素名称添加 "(Copy)" 后缀
- [x] 自动选中新元素：复制后新元素被选中，原元素取消选中
- [x] 多选复制：支持同时复制多个选中元素
- [x] 立即拖拽：复制后可立即拖拽移动新元素

### 6.8 拖拽辅助线

- [x] 中心水平辅助线：穿过选中元素中心的水平虚线
- [x] 中心垂直辅助线：穿过选中元素中心的垂直虚线
- [x] 边界辅助线 - 顶部：元素上边界的水平虚线
- [x] 边界辅助线 - 底部：元素下边界的水平虚线
- [x] 边界辅助线 - 左侧：元素左边界的垂直虚线
- [x] 边界辅助线 - 右侧：元素右边界的垂直虚线
- [x] 中心点标记：中心位置显示圆形标记
- [x] 多选支持：多选时显示整体边界框的辅助线
- [x] 仅在拖拽时显示：辅助线只在拖拽元素时出现
- [x] 自适应缩放：辅助线宽度和虚线间距随缩放自适应

---

## 七、设计决策

### 7.1 边界框计算策略

- **计算时机**: 每次渲染时实时计算（section 数据量小，性能可接受）
- **计算方式**: 使用 `getBoundingBox()` 从顶点计算 min/max 坐标
- **视觉样式**: 虚线蓝色边框，线宽随缩放自适应 (`1/scale`)

### 7.2 拖拽移动策略

- **增量计算**: 每次移动计算 delta，避免浮点误差累积
- **实时更新**: 直接更新 sections 状态，实现实时预览
- **多元素支持**: 拖拽时移动所有选中元素，保持相对位置

### 7.3 光标管理策略

- **React State**: 使用 `useState` 管理光标样式
- **优先级**: 平移 > 拖拽 > 工具特定光标 > 悬停光标
- **动态检测**: 根据 `hoverElementId` 和 `selectedIds` 动态判断

### 7.4 渲染层次策略

- **边界框层**: 位于 sections 层之上，避免被多边形遮挡
- **悬停层**: 位于边界框之下，不干扰选中状态视觉
- **pointerEvents**: 边界框层禁用事件（手柄除外），避免干扰拖拽

### 7.5 旋转功能策略

- **旋转中心**: 多选时使用整体边界框的中心点作为旋转中心
- **角度计算**: 使用 `Math.atan2()` 计算鼠标相对于中心的角度
- **增量旋转**: 记录起始角度，计算增量角度应用于元素
- **顶点旋转**: 使用旋转矩阵对每个顶点进行旋转 `x' = x*cosθ - y*sinθ`
- **实时预览**: 旋转过程中实时更新 sections 状态

#### 累积旋转误差修复

**问题**: 在旋转过程中，每一帧都基于当前已旋转的坐标继续旋转，导致误差累积，元素会越转越快或变形。

**解决方案**:

1. 旋转开始时，保存选中元素的原始坐标数据到 `originalSectionsRef`
2. 每一帧旋转时，从原始坐标重新计算，而不是基于已旋转的坐标
3. 旋转结束时，清理原始数据引用

```typescript
// 旋转开始 - 保存原始数据
originalSectionsRef.current = sections.filter(s => selectedIds.has(s.id));

// 旋转中 - 使用原始数据计算
const sourceSection = originalSections?.find(s => s.id === section.id) || section;
points: rotatePolygon(sourceSection.points, center, angle)
```

### 7.6 边界框旋转可视化策略

**问题**: 旋转过程中边界框应该如何显示？

**方案演变**:

1. **初始方案**: 旋转时隐藏边界框，避免视觉混乱
2. **改进方案**: 显示初始边界框但不跟随旋转，结束后重新计算
3. **最终方案**: 使用 SVG `transform` 属性让边界框跟随元素旋转，提供直观反馈

**实现**:

```tsx
// 使用 SVG transform 旋转整个边界框组
<g transform={`rotate(${rotationAngle}, ${centerX}, ${centerY})`}>
  <rect x={minX} y={minY} ... />  {/* 边界框矩形 */}
  <line ... />  {/* 手柄连接线 */}
  <circle ... />  {/* 旋转手柄 */}
  <text>{Math.round(rotationAngle)}°</text>  {/* 角度显示 */}
</g>
```

**视觉反馈**:

- 边界框跟随元素旋转，让用户直观看到旋转效果
- 显示旋转角度数值（如 "45°"）
- 显示旋转中心指示点和虚线圆圈

### 7.7 多选边界框策略

- **整体边界框**: 多选时计算所有选中元素的 minX/minY/maxX/maxY
- **子边界框**: 多选时可选显示每个元素的子边界框（半透明）
- **统一手柄**: 多选时只显示一个旋转手柄在整体边界框顶部中心

---

## 附录：工具函数实现

### A.1 旋转相关函数 (coordinate.ts)

```typescript
/**
 * 计算两点之间的角度（度数）
 * @param center - 中心点
 * @param point - 目标点
 * @returns 角度（0-360度）
 */
export function getAngle(center: Point, point: Point): number {
  const dx = point.x - center.x;
  const dy = point.y - center.y;
  let angle = Math.atan2(dy, dx) * (180 / Math.PI);
  if (angle < 0) {
    angle += 360;
  }
  return angle;
}

/**
 * 旋转点围绕中心点
 * @param point - 要旋转的点
 * @param center - 旋转中心
 * @param angle - 旋转角度（度数）
 * @returns 旋转后的点
 */
export function rotatePoint(point: Point, center: Point, angle: number): Point {
  const rad = angle * (Math.PI / 180);
  const cos = Math.cos(rad);
  const sin = Math.sin(rad);

  const dx = point.x - center.x;
  const dy = point.y - center.y;

  return {
    x: center.x + dx * cos - dy * sin,
    y: center.y + dx * sin + dy * cos,
  };
}

/**
 * 旋转多边形的所有顶点
 * @param points - 多边形顶点数组
 * @param center - 旋转中心
 * @param angle - 旋转角度（度数）
 * @returns 旋转后的顶点数组
 */
export function rotatePolygon(points: Point[], center: Point, angle: number): Point[] {
  return points.map(p => rotatePoint(p, center, angle));
}
```

### A.2 边界框相关函数 (selection.ts)

```typescript
/**
 * 计算多边形边界框
 */
export function getBoundingBox(points: Point[]): BoundingBox {
  const xs = points.map(p => p.x);
  const ys = points.map(p => p.y);
  return {
    minX: Math.min(...xs),
    minY: Math.min(...ys),
    maxX: Math.max(...xs),
    maxY: Math.max(...ys),
  };
}

/**
 * 计算组合边界框（多选时使用）
 */
export function getCombinedBoundingBox(bboxes: BoundingBox[]): BoundingBox {
  return {
    minX: Math.min(...bboxes.map(b => b.minX)),
    minY: Math.min(...bboxes.map(b => b.minY)),
    maxX: Math.max(...bboxes.map(b => b.maxX)),
    maxY: Math.max(...bboxes.map(b => b.maxY)),
  };
}

/**
 * 获取边界框中心点
 */
export function getBoundingBoxCenter(bbox: BoundingBox): Point {
  return {
    x: (bbox.minX + bbox.maxX) / 2,
    y: (bbox.minY + bbox.maxY) / 2,
  };
}
```

---

## 附录 B：复制功能实现（新增）

### B.1 App.tsx 复制处理函数

```typescript
/**
 * 处理复制选中元素
 * - Ctrl+C 或 Ctrl+D 复制选中元素
 * - 新元素位置偏移 +20px
 * - 新元素被选中，原元素取消选中
 */
const handleCopyElements = useCallback(() => {
  if (selectedIds.size === 0) return;

  const selectedSections = sections.filter(s => selectedIds.has(s.id));

  // 生成新元素，位置偏移
  const newSections: Section[] = selectedSections.map(section => {
    const newId = generateId();
    return {
      ...section,
      id: newId,
      name: `${section.name} (Copy)`,
      points: section.points.map(p => ({
        x: p.x + 20, // 向右偏移 20px
        y: p.y + 20, // 向下偏移 20px
      })),
    };
  });

  // 添加到 sections
  setSections(prev => [...prev, ...newSections]);

  // 选中新元素，取消原元素选中
  const newIds = new Set(newSections.map(s => s.id));
  setSelectedIds(newIds);
  setSelectedSectionId(newSections[0]?.id || null);
}, [sections, selectedIds, generateId]);
```

### B.2 App.tsx 完整键盘事件处理

```typescript
/**
 * 选择工具键盘快捷键
 * - Ctrl+A: 全选
 * - Ctrl+C / Ctrl+D: 复制选中元素
 * - Delete: 删除选中元素
 * - ESC: 取消选择
 */
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    // Ctrl+A 全选
    if ((e.key === 'a' || e.key === 'A') && (e.ctrlKey || e.metaKey) && activeTool === 'select') {
      e.preventDefault();
      const allIds = new Set(sections.map(s => s.id));
      setSelectedIds(allIds);
      const firstId = sections.length > 0 ? sections[0].id : null;
      setSelectedSectionId(firstId);
    }

    // Ctrl+C 或 Ctrl+D 复制
    if ((e.key === 'c' || e.key === 'C' || e.key === 'd' || e.key === 'D')
        && (e.ctrlKey || e.metaKey)
        && activeTool === 'select'
        && selectedIds.size > 0
        && !isDrawing) {
      e.preventDefault();
      handleCopyElements();
    }

    // Delete 删除选中元素
    if ((e.key === 'Delete' || e.key === 'Backspace') && selectedIds.size > 0 && activeTool === 'select' && !isDrawing) {
      e.preventDefault();
      // 从 sections 中删除选中的元素
      setSections(prev => prev.filter(s => !selectedIds.has(s.id)));
      setSelectedIds(new Set());
      setSelectedSectionId(null);
    }

    // ESC 取消选择
    if (e.key === 'Escape' && selectedIds.size > 0 && !isDrawing) {
      e.preventDefault();
      setSelectedIds(new Set());
      setSelectedSectionId(null);
    }
  };

  window.addEventListener('keydown', handleKeyDown);
  return () => {
    window.removeEventListener('keydown', handleKeyDown);
  };
}, [activeTool, sections, selectedIds, isDrawing, handleCopyElements]);
```

### B.3 事件监听冲突处理

**问题**: Canvas.tsx 和 App.tsx 都有键盘事件监听，造成删除功能冲突。

**解决方案**: 移除 Canvas.tsx 中的 Delete 处理，统一由 App.tsx 处理：

```typescript
// Canvas.tsx - 删除以下代码，由父组件统一处理
// if ((e.key === 'Delete' || e.key === 'Backspace') && ...) {
//   ...
// }

// 改为注释说明
// Note: Delete 删除选中元素由父组件 App.tsx 处理
// Canvas 只负责清空选择状态，不处理实际的 sections 删除
```

### B.4 设计决策

**偏移策略**
- **固定偏移**: +20px X 和 Y 方向
- **理由**: 简单、可见，用户能清楚看到复制结果
- **替代方案**: 智能偏移（根据视口计算），但固定偏移更简单可靠

**选择策略**
- **复制后**: 新元素被选中，原元素取消选中
- **理由**: 用户通常想立即操作复制的元素
- **替代方案**: 保持两者选中，但这会使移动复制元素变得困难

**快捷键**
- **Ctrl+C**: 标准复制快捷键
- **Ctrl+D**: 设计工具（如 Figma）常用快捷键
- **两者都支持**: 提高用户体验

### B.5 拖拽辅助线设计决策

**显示时机**
- **仅在拖拽时显示**: 减少视觉干扰，只在用户需要时出现
- **状态传递**: Canvas.tsx 使用 `isDraggingElement` state 传递给 SVGRenderer

**辅助线类型**
- **中心十字线**: 穿过元素中心的水平和垂直线，用于精确定位中心点
- **边界辅助线**: 在元素四条边界处显示，用于对齐相邻元素

**视觉样式**
- **颜色**: 琥珀色 (`#f59e0b`)，与蓝色选中状态形成对比
- **中心线**: 较粗 (1/scale)、较明显 (opacity 0.8)、虚线间隔 4,2
- **边界线**: 较细 (0.5/scale)、较淡 (opacity 0.6)、虚线间隔 2,2
- **中心点**: 圆形标记，帮助精确定位中心位置

**多选处理**
- **整体边界框**: 多选时计算所有选中元素的组合边界框
- **统一辅助线**: 显示整体边界框的辅助线，而不是每个元素的辅助线
- **避免混乱**: 减少辅助线数量，避免视觉混乱

**实现细节**
- **线长**: 使用 10000px 的线长确保覆盖整个画布
- **pointerEvents**: 禁用鼠标事件，避免干扰拖拽操作
- **自适应**: 线宽和虚线间距随缩放比例自适应 (`1/scale`)

### B.6 吸附容差缩放优化

**问题**
`findSnapPoint` 函数的吸附容差使用固定世界坐标值（10px/15px），导致：
- 放大时（scale > 1）：屏幕像素容差变小，难以触发吸附
- 缩小时（scale < 1）：屏幕像素容差变大，过远就触发吸附

**解决方案**
将屏幕像素容差转换为世界坐标容差：`tolerance / scale`

```typescript
export function findSnapPoint(
  point: Point,
  options: {
    gridSize?: number;
    vertices?: Point[];
    scale?: number;  // 新增缩放参数
  }
): SnapResult {
  const { scale = 1 } = options;

  // 将屏幕像素容差转换为世界坐标容差
  const gridTolerance = 10 / scale;     // 网格吸附：10屏幕像素
  const vertexTolerance = 15 / scale;   // 顶点吸附：15屏幕像素

  // 使用转换后的容差进行比较...
}
```

**效果对比**

| 缩放级别 | 修复前（世界坐标） | 修复后（屏幕像素） |
|---------|-------------------|-------------------|
| scale=2 (放大200%) | 10px → 屏幕 20px | 10px → 屏幕 10px |
| scale=0.5 (缩小50%) | 15px → 屏幕 7.5px | 15px → 屏幕 15px |

**设计原则**
- 用户感知的是屏幕像素距离，而非世界坐标距离
- 吸附容差应在所有缩放级别保持一致的用户体验
- `findAlignment` 已实现类似逻辑（`5/scale`），需保持一致

