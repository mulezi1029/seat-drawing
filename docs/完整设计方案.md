# 座位编辑器完整设计方案

> 基于 seats.io Designer 的架构设计，涵盖坐标系统、SVG 架构和交互模型

---

## 目录

1. [概述](#一概述)
2. [坐标系统](#二坐标系统)
3. [SVG 架构](#三svg-架构)
4. [交互模型](#四交互模型)
5. [架构总结](#五架构总结)

---

## 一、概述

### 核心设计理念

```
画布是假的
world 坐标是真的
SVG 只是渲染工具
```

### 整体架构分层

```
┌──────────────────────────┐
│     Interaction Layer    │  ← 鼠标/触控/快捷键
├──────────────────────────┤
│       Viewport Layer     │  ← scale / pan / zoom
├──────────────────────────┤
│      Scene Graph Layer   │  ← section / seat 数据
├──────────────────────────┤
│       Render Layer       │  ← SVG 或 Canvas
└──────────────────────────┘
```

---

## 二、坐标系统

### 2.1 为什么需要严谨的坐标系统

在 seats.io 的 Designer 中，画布从**交互体验**上看几乎是无限的，但从**技术实现**上看需要严格的坐标管理。

**常见错误**：

- 混用 world 和 screen 坐标
- 存 screen 坐标到数据
- 拖动时直接改 world
- zoom 后不重新计算 offset
- SVG transform 顺序写反

---

### 2.2 三套坐标系（必须全部建立）

很多人只做 2 套，这是错误根源。

#### 1️⃣ Screen Coordinate（屏幕坐标）

浏览器事件给你的：

```javascript
e.clientX
e.clientY
```

**特点**：

- 单位：px
- 相对于浏览器窗口
- 会受页面滚动影响

⚠️ **绝对不要直接用它存数据**

---

#### 2️⃣ Viewport Coordinate（视口坐标）

SVG 或 Canvas 容器内部坐标。

```javascript
const rect = container.getBoundingClientRect()
const viewportX = e.clientX - rect.left
const viewportY = e.clientY - rect.top
```

这一步只是把浏览器坐标转换到画布内部。

---

#### 3️⃣ World Coordinate（世界坐标）【核心】

所有数据都只用 world 坐标：

- section
- seat
- selection
- snapping

**存储结构**：

```typescript
interface WorldObject {
  id: string
  type: 'section' | 'seat'
  x: number
  y: number
}
```

---

### 2.3 坐标系设计原理

#### 为什么采用大坐标系而非真无限

**技术限制**：

- 浏览器数值有限（float 精度）
- SVG / Canvas 有最大尺寸限制

**大坐标会导致**：

- 精度丢失
- hit testing 错乱
- 性能问题

**推荐范围**：

```javascript
world = {
  minX: -100000,
  maxX: 100000,
  minY: -100000,
  maxY: 100000
}
```

> 足够大（用户感知不到边界），但有界可控。

---

### 2.4 核心公式（必须掌握）

#### world → screen

```javascript
screenX = worldX * scale + offsetX
screenY = worldY * scale + offsetY
```

#### screen → world

```javascript
worldX = (screenX - offsetX) / scale
worldY = (screenY - offsetY) / scale
```

⚠️ **所有鼠标事件都必须做这一步转换**

---

### 2.5 Viewport 结构

```typescript
interface Viewport {
  scale: number
  offsetX: number
  offsetY: number
}
```

**推荐初始化**：

```javascript
scale = 1
offsetX = canvasWidth / 2
offsetY = canvasHeight / 2
```

这样 world(0,0) 在画布中心。

---

### 2.6 关键交互实现

#### 1. 拖动画布（Pan）

**本质**：只改 offset，不动 world 数据

```javascript
offsetX += deltaX
offsetY += deltaY
```

---

#### 2. 以鼠标位置为中心的缩放

**错误写法**：

```javascript
scale *= 1.1  // ❌ 这样缩放中心会飘
```

**正确方式**：

```javascript
// 步骤 1：获取鼠标当前 world 坐标
const worldBefore = screenToWorld(mouseX, mouseY)

// 步骤 2：改变 scale
scale *= zoomFactor

// 步骤 3：重新计算 offset，保证缩放前后的 world 点不移动
offsetX = mouseX - worldBefore.x * scale
offsetY = mouseY - worldBefore.y * scale
```

👉 **这是无限画布手感的关键**

---

### 2.7 seats.io 为什么可以看起来"无限"

**原因一：背景 SVG 只是视觉参考层**

- 被当作 background layer
- 不会直接修改
- 也不影响坐标系

**结论**：画布 ≠ SVG 大小

---

**原因二：所有元素都是逻辑数据**

每个 seat 本质是结构化数据，不依赖 SVG 坐标系统。

```javascript
{
  id,
  x,
  y,
  row,
  label,
  category
}
```

---

**原因三：通过缩放 + 平移制造无限空间错觉**

只要 scale 不爆、translate 不溢出，理论上可以无限拖动。

---

### 2.8 边界控制

#### 缩放限制

```javascript
minScale = 0.2
maxScale = 5
```

不要允许 scale < 0.05，否则：

- float 精度丢失
- hit test 错位
- 选中框飘

#### 拖动限制

避免 offset 过大溢出。

---

### 2.9 Section 内部编辑的坐标处理

**答案**：不要创建新坐标系

所有 section 仍在 world 坐标。进入 section 只是：

```javascript
currentEditingSectionId = 'xxx'
```

**错误做法**：

- 创建新的局部坐标系
- 嵌套 transform
- 批量移动错位
- 导出数据复杂

---

## 三、SVG 架构

### 3.1 SVG 顶层结构

```svg
<svg class="designer-root">

  <!-- 1. 背景层（不可交互） -->
  <g id="background-layer"></g>

  <!-- 2. 视口层（唯一做 transform 的地方） -->
  <g id="viewport-layer">

    <!-- section 层 -->
    <g id="section-layer"></g>

    <!-- seat 层 -->
    <g id="seat-layer"></g>

    <!-- overlay 层（选中框 / hover） -->
    <g id="overlay-layer"></g>

  </g>

</svg>
```

⚠️ **核心原则**：只有 `viewport-layer` 允许做 transform，其他层绝对不要单独 scale。

---

### 3.2 为什么必须这样分层？

因为你要解决 5 个问题：

1. 无限缩放
2. 无限拖动
3. 背景 SVG 不污染数据
4. 选中框不被缩放影响
5. 命中检测精确

---

### 3.3 Transform 的应用

正确的 transform 应该只存在一处：

```javascript
viewport.setAttribute(
  'transform',
  `translate(${offsetX}, ${offsetY}) scale(${scale})`
)
```

❌ **不要这样做**：

- seat 上单独加 transform
- section 上单独加 transform
- background 上单独加 transform

> 后期必炸。

---

### 3.4 背景 SVG 处理

用户上传 SVG 底图的正确做法：

```svg
<g id="background-layer">
   <image href="user.svg" />
</g>
```

或者直接 `innerHTML` 插入 SVG。

**背景层必须满足**：

- 不参与 selection
- `pointer-events: none`
- 不允许修改

**否则你会陷入**：

- SVG DOM 混乱
- 数据与视图耦合
- hit test 失控

---

### 3.5 Section Layer 设计

每个 section：

```svg
<g class="section" data-id="xxx">
   <polygon />
   <text />
</g>
```

⚠️ **不要给 section 加 transform**。

Section 的移动应该：

```
修改 world 坐标 → 重新计算 points
```

而不是：

```svg
<g transform="translate(...)">  <!-- ❌ 编辑器常见大坑 -->
```

---

### 3.6 Seat Layer 设计

Seat 建议不要太复杂：

```svg
<g class="seat" data-id="s1">
   <circle />
   <text />
</g>
```

同样：

- 不单独 transform
- 坐标直接用 world 坐标渲染

---

### 3.7 Overlay Layer 为什么必须单独存在？

因为：**选中框不应该跟随 scale 改变线宽**。

如果 overlay 在 viewport 内：

```
scale 2 倍 → 选中线宽也 2 倍 ❌
```

#### 解决方案

**方案 A（推荐）**

Overlay 放在 viewport 内，但使用：

```svg
vector-effect="non-scaling-stroke"
```

保持线宽不变。

**方案 B**

Overlay 放在 viewport 外，手动做坐标转换。

> 更复杂，不建议。

---

### 3.8 常见错误架构（千万别这样）

#### ❌ 错误 1：每个 section 独立 transform

后果：

- 坐标系统变嵌套
- hit test 崩
- seat 批量移动混乱

#### ❌ 错误 2：seat 使用相对 section 坐标

看似合理：

```javascript
seat.x 相对于 section.x
```

但实际会导致：

- section 移动要级联更新所有 seat
- 性能问题
- 数据复杂

**正确方式**：

> 所有 seat 仍然使用 world 坐标，section 只是逻辑分组。

#### ❌ 错误 3：背景 SVG 和编辑数据混在一起

很多人直接修改用户上传的 SVG。

> ⚠️ 这是架构级错误。

编辑数据必须独立于背景 SVG。

---

### 3.9 SVG vs Canvas 在架构上的差异


| 场景             | 推荐方案       |
| -------------- | ---------- |
| seat 数量 < 3000 | SVG 架构没问题  |
| seat 数量 > 5000 | SVG DOM 会卡 |


seat 数量多时，你需要：

- 保留 scene graph
- 替换 render layer 为 Canvas

也就是说：**架构必须保证 render 层可替换**。

---

### 3.10 检查清单

你当前的 SVG 结构是否满足：

- 只有一个 transform 根节点
- seat 不使用 transform
- section 不使用 transform
- overlay 独立
- 背景设置 `pointer-events: none`

> 如果不满足第一条，先改。

---

### 3.11 工业级建议

**不要把 SVG 当 DOM**。

把它当：**纯渲染引擎**。

真正的数据结构应该是：

```javascript
scene = {
  sections: Map,
  seats: Map,
}
```

然后：

```javascript
render(scene, viewport)
```

永远单向流。

---

## 四、交互模型

### 4.1 为什么交互模型比坐标系统还关键


| 系统   | 解决的问题    |
| ---- | -------- |
| 坐标系统 | 数学问题     |
| 交互模型 | 编辑器是否可扩展 |


如果交互模型设计错了，后面添加以下功能都会变成灾难：

- 框选
- 多选
- 拖拽
- 批量绘制
- 吸附
- 键盘操作
- 撤销重做

---

### 4.2 交互模型核心思想

#### ❌ 不要这样写

```javascript
if (mode === 'drawSeat') { ... }
if (mode === 'drawSection') { ... }
```

这种会炸。

#### ✅ 应该这样设计

> **状态机 + 工具系统（Tool System）**

---

### 4.3 编辑器应该是"工具驱动"的

#### Tool 接口定义

```typescript
interface Tool {
  onMouseDown(e: MouseEvent): void
  onMouseMove(e: MouseEvent): void
  onMouseUp(e: MouseEvent): void
  onKeyDown(e: KeyboardEvent): void
  onKeyUp(e: KeyboardEvent): void
  onCancel(): void
}
```

#### 使用方式

```javascript
currentTool: Tool

// 所有事件都交给 currentTool
```

---

### 4.4 推荐的工具分类

#### 1️⃣ ViewTool（默认）

- 拖动画布
- 缩放
- 点击选中

#### 2️⃣ SelectTool

- 单选
- 多选
- 框选
- Shift 多选

#### 3️⃣ DrawSectionTool

- 点击创建 polygon
- 双击结束
- Esc 取消

#### 4️⃣ DrawSeatTool

- 单点绘制
- 横排绘制
- 弧形绘制

#### 5️⃣ MoveTool

- 拖动对象
- 批量移动

#### 6️⃣ ResizeTool（未来扩展）

- 形变 section

---

### 4.5 事件流设计

```javascript
canvas.addEventListener('mousedown', e => {
  currentTool.onMouseDown(convertToWorld(e))
})
```

⚠️ **注意**：传给 Tool 的必须是 **world 坐标**，不要把 screen 坐标传进去。

---

### 4.6 选择模型（非常关键）

#### ❌ 不要在 DOM 上存 selected

#### ✅ 维护独立的选择集合

```javascript
selection = new Set<string>()
```

#### 选中流程

```
hitTest(worldPoint) → 返回 objectId → 更新 selection → render()
```

---

### 4.7 hitTest 设计

#### ❌ 不要用 DOM event.target

#### ✅ 自定义命中检测

```javascript
function hitTest(worldX: number, worldY: number): string | null
```

#### 实现方式

- 遍历 seat：判断点是否在圆内
- 遍历 section polygon：pointInPolygon 判断

> 以后如果换 Canvas，逻辑不变。

---

### 4.8 拖动对象的正确流程

#### ❌ 错误方式

```
mousemove 直接改数据
```

#### ✅ 正确方式

```javascript
// onMouseDown
record startWorldPoint
record originalPositions

// onMouseMove
delta = currentWorld - startWorld
apply delta to originalPositions

// onMouseUp
commit command (进入 undo 栈)
```

---

### 4.9 交互必须是"命令驱动"

#### ❌ 不要直接改数据

#### ✅ 设计 Command 模式

```typescript
interface Command {
  execute(): void
  undo(): void
}
```

#### 示例

```javascript
class MoveCommand implements Command
class CreateSeatCommand implements Command
class DeleteCommand implements Command
```

#### 这样你可以实现

- Ctrl + Z
- Ctrl + Y
- 批量操作

> 这一步如果不做，后面一定重构。

---

### 4.10 模式切换不要用 boolean

#### ❌ 不要这样写

```javascript
isDrawing
isDragging
isSelecting
```

#### ✅ 应该这样写

```javascript
currentTool = new DrawSeatTool()
```

工具负责自己的内部状态。

---

### 4.11 进入 Section 编辑如何处理

#### ❌ 不要创建新坐标系

#### ✅ 只做状态标记

```javascript
currentEditingSectionId = 'xxx'
```

然后：

- hitTest 限制在该 section 内
- 绘制限制在 polygon 内
- 坐标仍然使用 world

---

### 4.12 框选实现

#### 逻辑流程

```
记录 dragStart world
mousemove 画一个临时矩形（overlay 层）
遍历对象，判断是否在矩形内
更新 selection
```

---

### 4.13 Shift / Ctrl 多选

不要写死逻辑，在 SelectTool 内部处理：

```javascript
if (e.shiftKey) {
  selection.add(id)
} else {
  selection.clear()
  selection.add(id)
}
```

---

### 4.14 工具系统结构示例

```javascript
class Editor {
  viewport
  scene
  selection
  currentTool

  setTool(tool) {
    this.currentTool = tool
  }
}
```

---

### 4.15 完整交互模型结构图

```
User Input
    ↓
Event Dispatcher
    ↓
Current Tool
    ↓
Command
    ↓
Scene Update
    ↓
Render
```

> 这才是编辑器架构。

---

### 4.16 为什么 seats.io 手感那么好

像 seats.io 这种编辑器：

- ✅ 统一 world 坐标
- ✅ 工具驱动
- ✅ 命令系统
- ✅ 选择独立
- ✅ 渲染层可替换

**不是因为 SVG 牛，是因为交互模型清晰。**

---

### 4.17 自检清单

你当前代码是否满足：

- 使用 currentTool？
- 事件是否统一分发？
- 是否有 selection 模型？
- 是否有 command 栈？
- 是否直接改 DOM？

> ⚠️ 如果第 5 条是 yes，建议立即停下来重构。

---

## 五、架构总结

### 核心原则

1. **画布是假的，world 坐标是真的**
2. **SVG 只是渲染工具，不参与数据逻辑**
3. **所有操作在 world 坐标系完成，通过 viewport 转换到屏幕**
4. **不要直接修改 SVG，维护独立的数据层**
5. **使用工具系统驱动交互，命令模式管理操作**

### 完整架构图

```
┌─────────────────────────────────────────┐
│           User Interaction              │
│  (Mouse, Keyboard, Touch, Shortcut)     │
└─────────────────┬───────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│         Event Dispatcher                │
│  (Convert to World Coordinates)         │
└─────────────────┬───────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│           Current Tool                  │
│  (ViewTool, SelectTool, DrawTool...)    │
└─────────────────┬───────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│         Command Pattern                 │
│  (MoveCommand, CreateCommand...)        │
│         ↓ Execute / Undo ↓              │
└─────────────────┬───────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│          Scene Graph                    │
│  sections: Map<id, Section>             │
│  seats: Map<id, Seat>                   │
│  selection: Set<id>                     │
└─────────────────┬───────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│     Render (SVG / Canvas)               │
│  (Pure rendering, no state)             │
└─────────────────────────────────────────┘
```

### 一句话总结

> **seats.io 的画布 = 超大世界坐标系 + 视口变换机制 + 工具驱动交互 + 命令模式管理 + 惰性渲染**

- 从用户感知上是无限
- 从技术实现上是有限但足够大
- 从架构设计上是清晰且可扩展的

