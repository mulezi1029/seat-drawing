# 交互模型设计方案

> 编辑器级交互模型（可直接用于复刻 seats.io 级别的 Designer）

---

## 为什么交互模型比坐标系统还关键

| 系统 | 解决的问题 |
|------|-----------|
| 坐标系统 | 数学问题 |
| 交互模型 | 编辑器是否可扩展 |

如果交互模型设计错了，后面添加以下功能都会变成灾难：

- 框选
- 多选
- 拖拽
- 批量绘制
- 吸附
- 键盘操作
- 撤销重做

---

## 一、交互模型核心思想

### ❌ 不要这样写

```javascript
if (mode === 'drawSeat') { ... }
if (mode === 'drawSection') { ... }
```

这种会炸。

### ✅ 应该这样设计

> **状态机 + 工具系统（Tool System）**

---

## 二、编辑器应该是"工具驱动"的

### Tool 接口定义

```typescript
interface Tool {
  onMouseDown(e: MouseEvent): void
  onMouseMove(e: MouseEvent): void
  onMouseUp(e: MouseEvent): void
  onKeyDown(e: KeyboardEvent): void
  onKeyUp(e: KeyboardEvent): void
  onCancel(): void
}
```

### 使用方式

```javascript
currentTool: Tool

// 所有事件都交给 currentTool
```

---

## 三、推荐的工具分类

### 1️⃣ ViewTool（默认）

- 拖动画布
- 缩放
- 点击选中

### 2️⃣ SelectTool

- 单选
- 多选
- 框选
- Shift 多选

### 3️⃣ DrawSectionTool

- 点击创建 polygon
- 双击结束
- Esc 取消

### 4️⃣ DrawSeatTool

- 单点绘制
- 横排绘制
- 弧形绘制

### 5️⃣ MoveTool

- 拖动对象
- 批量移动

### 6️⃣ ResizeTool（未来扩展）

- 形变 section

---

## 四、事件流设计

```javascript
canvas.addEventListener('mousedown', e => {
  currentTool.onMouseDown(convertToWorld(e))
})
```

⚠️ **注意**：传给 Tool 的必须是 **world 坐标**，不要把 screen 坐标传进去。

---

## 五、选择模型（非常关键）

### ❌ 不要在 DOM 上存 selected

### ✅ 维护独立的选择集合

```javascript
selection = new Set<string>()
```

### 选中流程

```
hitTest(worldPoint) → 返回 objectId → 更新 selection → render()
```

---

## 六、hitTest 设计

### ❌ 不要用 DOM event.target

### ✅ 自定义命中检测

```javascript
function hitTest(worldX: number, worldY: number): string | null
```

### 实现方式

- 遍历 seat：判断点是否在圆内
- 遍历 section polygon：pointInPolygon 判断

> 以后如果换 Canvas，逻辑不变。

---

## 七、拖动对象的正确流程

### ❌ 错误方式

```
mousemove 直接改数据
```

### ✅ 正确方式

```javascript
// onMouseDown
record startWorldPoint
record originalPositions

// onMouseMove
delta = currentWorld - startWorld
apply delta to originalPositions

// onMouseUp
commit command (进入 undo 栈)
```

---

## 八、交互必须是"命令驱动"

### ❌ 不要直接改数据

### ✅ 设计 Command 模式

```typescript
interface Command {
  execute(): void
  undo(): void
}
```

### 示例

```javascript
class MoveCommand implements Command
class CreateSeatCommand implements Command
class DeleteCommand implements Command
```

### 这样你可以实现

- Ctrl + Z
- Ctrl + Y
- 批量操作

> 这一步如果不做，后面一定重构。

---

## 九、模式切换不要用 boolean

### ❌ 不要这样写

```javascript
isDrawing
isDragging
isSelecting
```

### ✅ 应该这样写

```javascript
currentTool = new DrawSeatTool()
```

工具负责自己的内部状态。

---

## 十、进入 Section 编辑如何处理

### ❌ 不要创建新坐标系

### ✅ 只做状态标记

```javascript
currentEditingSectionId = 'xxx'
```

然后：

- hitTest 限制在该 section 内
- 绘制限制在 polygon 内
- 坐标仍然使用 world

---

## 十一、框选实现

### 逻辑流程

```
记录 dragStart world
mousemove 画一个临时矩形（overlay 层）
遍历对象，判断是否在矩形内
更新 selection
```

---

## 十二、Shift / Ctrl 多选

不要写死逻辑，在 SelectTool 内部处理：

```javascript
if (e.shiftKey) {
  selection.add(id)
} else {
  selection.clear()
  selection.add(id)
}
```

---

## 十三、工具系统结构示例

```javascript
class Editor {
  viewport
  scene
  selection
  currentTool

  setTool(tool) {
    this.currentTool = tool
  }
}
```

---

## 十四、完整交互模型结构图

```
User Input
    ↓
Event Dispatcher
    ↓
Current Tool
    ↓
Command
    ↓
Scene Update
    ↓
Render
```

> 这才是编辑器架构。

---

## 十五、为什么 seats.io 手感那么好

像 seats.io 这种编辑器：

- ✅ 统一 world 坐标
- ✅ 工具驱动
- ✅ 命令系统
- ✅ 选择独立
- ✅ 渲染层可替换

**不是因为 SVG 牛，是因为交互模型清晰。**

---

## 十六、自检清单

你当前代码是否满足：

- [ ] 使用 currentTool？
- [ ] 事件是否统一分发？
- [ ] 是否有 selection 模型？
- [ ] 是否有 command 栈？
- [ ] 是否直接改 DOM？

> ⚠️ 如果第 5 条是 yes，建议立即停下来重构。
