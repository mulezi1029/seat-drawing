# 座位选择边界框功能说明

## 概述

当在 section 编辑模式中选中座位后，系统会自动显示一个蓝色虚线边界框（Bounding Box），包围所有选中的座位。边界框提供了直观的视觉反馈，并支持整组拖拽和旋转操作。

## 功能特性

### 1. 边界框显示

**触发条件**：
- 选中一个或多个座位
- 当前工具为"选择工具"（select）
- 不在绘制、拖拽或框选状态

**视觉元素**：
```
┌─────────────────────┐
│  ╔═══════════════╗  │  ← 蓝色虚线边界框
│  ║               ║  │
│  ║   ● ● ● ●    ║  │  ← 选中的座位
│  ║               ║  │
│  ╚═══════════════╝  │
│         │           │
│         ●           │  ← 旋转手柄
└─────────────────────┘
```

**样式规范**：
- **边框颜色**：蓝色 `#3b82f6`
- **边框样式**：虚线 `strokeDasharray="4,2"`
- **边框宽度**：1px（随缩放自适应）
- **填充**：无填充（透明）

### 2. 旋转手柄

**位置**：
- 边界框顶部中心
- 距离边界框顶边 20px（世界坐标）
- 通过连接线与边界框相连

**外观**：
- **形状**：圆形
- **半径**：6px（世界坐标）
- **填充**：蓝色 `#3b82f6`
- **边框**：白色 2px
- **光标**：
  - 非旋转状态：`grab`
  - 旋转状态：`grabbing`

**连接线**：
- 从边界框顶部中心到旋转手柄
- 颜色：蓝色 `#3b82f6`
- 宽度：1px（随缩放自适应）

### 3. 边界框内拖拽

**功能说明**：
在边界框范围内的任意位置点击并拖拽，可以移动整组选中的座位。

**操作流程**：
```
1. 选中座位（显示边界框）
2. 在边界框内任意位置按住鼠标
3. 拖拽移动
4. 释放鼠标完成移动
```

**与座位拖拽的区别**：
| 操作 | 触发条件 | 效果 |
|------|---------|------|
| 座位拖拽 | 点击已选中的座位 | 移动所有选中座位 |
| 边界框拖拽 | 点击边界框内空白区域 | 移动所有选中座位 |

**注意事项**：
- 边界框拖拽与座位拖拽效果相同
- 都是移动整组选中的座位
- 提供更大的可拖拽区域，提升用户体验

### 4. 旋转功能

#### 4.1 开始旋转

**触发方式**：
点击并拖拽旋转手柄（边界框顶部的蓝色圆点）

**检测逻辑**：
```typescript
// 检测点击是否在旋转手柄范围内
const isClickOnRotationHandle = (worldPos: Point, bbox: BoundingBox): boolean => {
  const centerX = (bbox.minX + bbox.maxX) / 2;
  const handleY = bbox.minY - 20 / canvasScale;
  const handleRadius = 10 / canvasScale;  // 容差半径
  
  const dx = worldPos.x - centerX;
  const dy = worldPos.y - handleY;
  return Math.sqrt(dx * dx + dy * dy) <= handleRadius;
};
```

**旋转中心**：
- 边界框的几何中心点
- 计算方式：`centerX = (minX + maxX) / 2`, `centerY = (minY + maxY) / 2`

#### 4.2 旋转过程

**实时反馈**：
1. **边界框旋转**：
   - 边界框跟随鼠标旋转
   - 使用 SVG `transform="rotate(angle, centerX, centerY)"`

2. **座位预览**：
   - 所有选中座位实时显示旋转后的位置
   - 座位透明度降低至 0.6（半透明）
   - 座位角度同步更新

3. **角度显示**：
   - 在旋转手柄上方显示当前旋转角度
   - 格式：整数角度 + "°" 符号（如 "45°"）
   - 颜色：蓝色粗体

**旋转计算**：
```typescript
const rotateSeat = (seat: Seat, center: Point, angle: number): Seat => {
  const rad = angle * (Math.PI / 180);
  const cos = Math.cos(rad);
  const sin = Math.sin(rad);
  
  // 计算相对于旋转中心的偏移
  const dx = seat.x - center.x;
  const dy = seat.y - center.y;
  
  // 旋转变换
  return {
    ...seat,
    x: center.x + dx * cos - dy * sin,
    y: center.y + dx * sin + dy * cos,
    angle: seat.angle + angle,  // 累加旋转角度
  };
};
```

#### 4.3 完成旋转

**触发方式**：
释放鼠标左键

**执行操作**：
1. 计算所有选中座位的最终旋转位置
2. 调用 `onUpdateSeats()` 更新座位数据
3. 清除旋转状态
4. 座位恢复正常显示（不透明）

**数据更新**：
```typescript
const rotatedSeats = originalSeatsRef.current.map((seat) =>
  rotateSeat(seat, rotationCenter, rotationAngle)
);
onUpdateSeats(rotatedSeats);
```

## 交互优先级

在 `handleMouseDown` 中的检测顺序：

```typescript
1. 检测旋转手柄点击
   ↓ 否
2. 检测座位点击（已选中）
   ↓ 否
3. 检测边界框内点击
   ↓ 否
4. 开始框选
```

**优先级说明**：
- **最高优先级**：旋转手柄（避免与拖拽冲突）
- **次优先级**：已选中的座位（精确拖拽）
- **第三优先级**：边界框内区域（大范围拖拽）
- **最低优先级**：空白区域（框选）

## 状态管理

### 旋转相关状态

```typescript
// 是否正在旋转
const [isRotating, setIsRotating] = useState(false);

// 当前旋转角度（相对于起始角度的增量）
const [rotationAngle, setRotationAngle] = useState(0);

// 旋转中心点（边界框的几何中心）
const [rotationCenter, setRotationCenter] = useState<Point | null>(null);

// 旋转开始时鼠标的角度
const [rotationStartAngle, setRotationStartAngle] = useState(0);

// 原始座位数据（避免累积误差）
const originalSeatsRef = useRef<Seat[]>([]);
```

### 边界框计算

```typescript
const selectedSeatsBbox = useMemo((): BoundingBox | null => {
  if (selectedSeatIds.size === 0) return null;
  
  const selectedSeats = seats.filter((s) => selectedSeatIds.has(s.id));
  if (selectedSeats.length === 0) return null;
  
  const seatPoints = selectedSeats.map((s) => ({ x: s.x, y: s.y }));
  return getBoundingBox(seatPoints);
}, [selectedSeatIds, seats]);
```

**性能优化**：
- 使用 `useMemo` 缓存计算结果
- 只在 `selectedSeatIds` 或 `seats` 变化时重新计算

## 视觉状态

### 非旋转状态

```svg
<!-- 边界框矩形 -->
<rect
  x={bbox.minX}
  y={bbox.minY}
  width={bbox.maxX - bbox.minX}
  height={bbox.maxY - bbox.minY}
  fill="none"
  stroke="#3b82f6"
  strokeWidth={1 / canvasScale}
  strokeDasharray={`${4 / canvasScale},${2 / canvasScale}`}
/>

<!-- 旋转手柄连接线 -->
<line
  x1={centerX}
  y1={bbox.minY}
  x2={centerX}
  y2={bbox.minY - 20 / canvasScale}
  stroke="#3b82f6"
  strokeWidth={1 / canvasScale}
/>

<!-- 旋转手柄圆点 -->
<circle
  cx={centerX}
  cy={bbox.minY - 20 / canvasScale}
  r={6 / canvasScale}
  fill="#3b82f6"
  stroke="white"
  strokeWidth={2 / canvasScale}
  style={{ cursor: 'grab' }}
/>
```

### 旋转状态

```svg
<!-- 整个边界框组应用旋转变换 -->
<g transform={`rotate(${rotationAngle}, ${centerX}, ${centerY})`}>
  <!-- 边界框矩形（半透明） -->
  <rect opacity={0.8} ... />
  
  <!-- 旋转手柄连接线 -->
  <line ... />
  
  <!-- 旋转手柄圆点 -->
  <circle style={{ cursor: 'grabbing' }} ... />
  
  <!-- 角度文本 -->
  <text
    x={centerX}
    y={handleY - 15 / canvasScale}
    textAnchor="middle"
    fontSize={12 / canvasScale}
    fill="#3b82f6"
    fontWeight="bold"
  >
    {Math.round(rotationAngle)}°
  </text>
</g>
```

## 使用场景

### 场景 1：调整单排座位角度

```
1. 使用单排工具绘制一排水平座位
2. 按 V 或 ESC 切换到选择工具
3. 单击任意座位，选中整排
4. 拖拽旋转手柄，调整座位角度
5. 释放鼠标，完成旋转
```

### 场景 2：旋转多组座位

```
1. 绘制多排座位
2. 框选多排座位
3. 拖拽旋转手柄
4. 所有选中座位围绕共同中心旋转
5. 释放鼠标完成旋转
```

### 场景 3：精确角度调整

```
1. 选中座位
2. 拖拽旋转手柄
3. 观察实时显示的角度数值
4. 调整到目标角度（如 45°）
5. 释放鼠标
```

## 技术要点

### 1. 坐标系统

- **世界坐标系**：用于所有计算和存储
- **屏幕坐标系**：用于鼠标事件
- **转换函数**：`screenToWorld()` 进行坐标转换

### 2. 旋转数学

**角度计算**：
```typescript
const getAngle = (center: Point, point: Point): number => {
  return Math.atan2(point.y - center.y, point.x - center.x);
};
```

**旋转矩阵**：
```
[ cos(θ)  -sin(θ) ]
[ sin(θ)   cos(θ) ]
```

**应用旋转**：
```
x' = centerX + (x - centerX) * cos(θ) - (y - centerY) * sin(θ)
y' = centerY + (x - centerX) * sin(θ) + (y - centerY) * cos(θ)
```

### 3. 避免累积误差

**问题**：
多次旋转会累积浮点数误差，导致座位位置偏移

**解决方案**：
```typescript
// 保存原始座位数据
originalSeatsRef.current = seats.filter((s) => selectedSeatIds.has(s.id));

// 每次计算都基于原始数据
const rotatedSeats = originalSeatsRef.current.map((seat) =>
  rotateSeat(seat, rotationCenter, rotationAngle)
);
```

### 4. 性能优化

**边界框计算**：
- 使用 `useMemo` 缓存
- 只在必要时重新计算

**旋转预览**：
- 只计算选中的座位
- 使用 CSS `opacity` 而不是重新渲染

**事件处理**：
- 使用 `useCallback` 避免重复创建函数
- 合理使用 `e.stopPropagation()` 避免事件冒泡

## 与主画布的一致性

座位编辑模式的边界框功能完全参照主画布的 section 选择边界框实现：

**共同特性**：
- ✅ 蓝色虚线边界框
- ✅ 顶部旋转手柄
- ✅ 实时旋转预览
- ✅ 角度文本显示
- ✅ 边界框内拖拽

**差异**：
- 主画布：操作 section 多边形
- 编辑模式：操作 seat 矩形

**代码复用**：
- `getBoundingBox()` 工具函数
- `getAngle()` 工具函数
- 相同的视觉样式和交互逻辑

## 注意事项

1. **旋转手柄优先级**：
   - 旋转手柄检测必须在其他交互之前
   - 避免与座位拖拽冲突

2. **状态清理**：
   - 旋转完成后清除所有旋转状态
   - 避免状态残留影响后续操作

3. **事件传播**：
   - 座位的 `onMouseDown` 必须 `stopPropagation()`
   - 防止触发 canvas 的 `handleMouseDown`

4. **边界框显示条件**：
   - 只在选择工具模式下显示
   - 不在绘制、拖拽、框选状态时显示
   - 避免视觉混乱

5. **缩放适配**：
   - 所有尺寸（边框宽度、手柄大小）都除以 `canvasScale`
   - 确保在不同缩放级别下视觉一致

## 未来扩展

可能的功能扩展：

1. **缩放手柄**：
   - 边界框四角添加缩放手柄
   - 支持整组座位缩放

2. **吸附对齐**：
   - 旋转时吸附到 0°, 45°, 90° 等角度
   - 提供更精确的角度控制

3. **多点触控**：
   - 支持触摸屏双指旋转
   - 提升移动设备体验

4. **键盘快捷键**：
   - `Shift` + 拖拽：15° 增量旋转
   - `Ctrl` + 方向键：微调旋转角度

## 总结

座位选择边界框功能为用户提供了直观、高效的座位操作方式：

- **视觉反馈**：清晰的边界框和旋转手柄
- **灵活操作**：支持拖拽和旋转
- **实时预览**：所见即所得
- **一致体验**：与主画布保持一致

这一功能显著提升了座位编辑的用户体验，使得批量操作更加便捷高效。
