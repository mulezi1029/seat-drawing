# 座位坐标系统修复记录

## 问题描述

### 现象

在使用座位绘制功能时，发现座位位置不跟随 section 移动：

1. 在 section 编辑模式中绘制座位
2. 保存并返回主画布
3. 拖动移动 section 到新位置
4. 再次进入 section 编辑模式
5. **问题**：座位仍在原位置，与 section 边界不匹配

### 用户体验问题

```
场景：调整场馆布局

步骤 1：在区域 A 中绘制 100 个座位
步骤 2：保存座位
步骤 3：发现区域 A 位置不合适，移动到右侧
步骤 4：再次进入区域 A 编辑座位
步骤 5：❌ 发现座位还在左侧原位置，不在区域内

预期：座位应该跟随区域移动
实际：座位位置固定，与区域分离
```

### 视觉示例

```
初始状态：
┌─────────────┐
│  Section A  │
│   ● ● ●     │  ← 座位在 section 内
│   ● ● ●     │
└─────────────┘

移动 section 后：
                ┌─────────────┐
                │  Section A  │
                │             │  ← section 移动了
                │             │
                └─────────────┘
   ● ● ●                          ← 座位还在原位置 ❌
   ● ● ●
```

## 原因分析

### 坐标系统设计

应用使用三套坐标系统：

1. **屏幕坐标系（Screen）**
   - 原点：浏览器窗口左上角
   - 单位：像素（px）
   - 用途：鼠标事件、DOM 元素

2. **世界坐标系（World）**
   - 原点：虚拟画布中心 (0, 0)
   - 范围：(-25000, -25000) ~ (25000, 25000)
   - 单位：世界单位
   - 用途：所有数据存储

3. **局部坐标系（Local）**
   - 原点：Section 边界框左上角
   - 范围：相对于 section
   - 单位：世界单位
   - 用途：相对位置

### 当前实现问题

**Section 数据结构**：
```typescript
interface Section {
  id: string;
  name: string;
  points: Point[];     // 世界坐标
  seats: Seat[];       // ❌ 应该是局部坐标，实际是世界坐标
  // ...
}
```

**Seat 数据结构**：
```typescript
interface Seat {
  id: string;
  x: number;           // ❌ 世界坐标（应该是局部坐标）
  y: number;           // ❌ 世界坐标（应该是局部坐标）
  row: string;
  number: number;
  // ...
}
```

**问题根源**：

座位坐标使用世界坐标系存储，导致：

```typescript
// 保存座位时（修复前）
const handleSave = () => {
  onSaveSeats(section.id, seats);  // 直接保存世界坐标
};

// 加载座位时（修复前）
const [seats, setSeats] = useState(section.seats || []);  // 直接使用世界坐标
```

**移动 section 时的问题**：

```typescript
// 主画布中移动 section
const handleMove = (sectionId, dx, dy) => {
  setSections(prev => prev.map(s => {
    if (s.id === sectionId) {
      return {
        ...s,
        points: s.points.map(p => ({
          x: p.x + dx,  // ✅ section 顶点更新
          y: p.y + dy,
        })),
        seats: s.seats,  // ❌ 座位坐标不更新
      };
    }
    return s;
  }));
};
```

**结果**：
- Section 的顶点坐标更新了
- 座位的坐标没有更新
- 座位和 section 分离

### 坐标转换缺失

应用已经实现了坐标转换函数：

```typescript
// app/src/utils/coordinate.ts

// 世界坐标 → 局部坐标
export function worldToLocal(worldPoint: Point, sectionOrigin: Point): Point {
  return {
    x: worldPoint.x - sectionOrigin.x,
    y: worldPoint.y - sectionOrigin.y,
  };
}

// 局部坐标 → 世界坐标
export function localToWorld(localPoint: Point, sectionOrigin: Point): Point {
  return {
    x: localPoint.x + sectionOrigin.x,
    y: localPoint.y + sectionOrigin.y,
  };
}
```

但是在座位保存和加载时**没有使用**这些函数。

## 解决方案

### 核心思路

座位坐标应该相对于 section 存储：

1. **存储**：座位使用局部坐标（相对于 section 原点）
2. **编辑**：座位使用世界坐标（便于绘制和操作）
3. **保存时**：世界坐标 → 局部坐标
4. **加载时**：局部坐标 → 世界坐标

### Section 原点定义

Section 原点定义为边界框的左上角：

```typescript
const sectionOrigin = useMemo(() => {
  const bbox = getBoundingBox(section.points);
  return { 
    x: bbox.minX,  // 最小 x 坐标
    y: bbox.minY,  // 最小 y 坐标
  };
}, [section.points]);
```

**示例**：
```
Section 顶点: [(100, 100), (200, 100), (200, 200), (100, 200)]
边界框: minX=100, minY=100, maxX=200, maxY=200
原点: (100, 100)
```

### 加载座位（局部 → 世界）

进入编辑模式时，将局部坐标转换为世界坐标：

```typescript
const [seats, setSeats] = useState<Seat[]>(() => {
  const savedSeats = section.seats || [];
  
  // 将局部坐标转换为世界坐标
  return savedSeats.map(seat => ({
    ...seat,
    x: seat.x + sectionOrigin.x,  // 局部 x + 原点 x = 世界 x
    y: seat.y + sectionOrigin.y,  // 局部 y + 原点 y = 世界 y
  }));
});
```

**转换示例**：
```
Section 原点: (100, 100)
保存的座位（局部坐标）: { x: 50, y: 50 }

加载时转换：
  世界 x = 50 + 100 = 150
  世界 y = 50 + 100 = 150
  
加载后座位（世界坐标）: { x: 150, y: 150 }
```

### 保存座位（世界 → 局部）

保存座位时，将世界坐标转换为局部坐标：

```typescript
const handleSave = useCallback(() => {
  // 将世界坐标转换为局部坐标
  const localSeats = seats.map(seat => ({
    ...seat,
    x: seat.x - sectionOrigin.x,  // 世界 x - 原点 x = 局部 x
    y: seat.y - sectionOrigin.y,  // 世界 y - 原点 y = 局部 y
  }));
  
  onSaveSeats(section.id, localSeats);
  onBack();
}, [section.id, seats, sectionOrigin, onSaveSeats, onBack]);
```

**转换示例**：
```
Section 原点: (100, 100)
编辑中的座位（世界坐标）: { x: 150, y: 150 }

保存时转换：
  局部 x = 150 - 100 = 50
  局部 y = 150 - 100 = 50
  
保存后座位（局部坐标）: { x: 50, y: 50 }
```

### 完整流程

```
1. 进入编辑模式
   ↓
2. 计算 section 原点: (100, 100)
   ↓
3. 加载座位（局部 → 世界）
   保存的: { x: 50, y: 50 }
   加载为: { x: 150, y: 150 }
   ↓
4. 用户绘制/编辑座位（世界坐标）
   座位: { x: 150, y: 150 }
   ↓
5. 保存座位（世界 → 局部）
   编辑的: { x: 150, y: 150 }
   保存为: { x: 50, y: 50 }
   ↓
6. 返回主画布
   ↓
7. 移动 section
   原点: (100, 100) → (300, 300)
   ↓
8. 再次进入编辑模式
   ↓
9. 计算新原点: (300, 300)
   ↓
10. 加载座位（局部 → 世界）
    保存的: { x: 50, y: 50 }
    加载为: { x: 350, y: 350 }  ✅ 正确跟随
```

## 修改的文件

### `app/src/components/section-edit/EditMode.tsx`

#### 1. 添加导入

```typescript
import React, { useState, useCallback, useMemo } from 'react';
import { getBoundingBox } from '@/utils/selection';
```

#### 2. 计算 section 原点

```typescript
// 计算 section 的原点（边界框左上角）
const sectionOrigin = useMemo(() => {
  const bbox = getBoundingBox(section.points);
  return { x: bbox.minX, y: bbox.minY };
}, [section.points]);
```

**说明**：
- 使用 `useMemo` 缓存计算结果
- 依赖 `section.points`，当 section 移动时自动重新计算
- 原点始终是边界框的左上角

#### 3. 修改座位初始化

**修改前**：
```typescript
const [seats, setSeats] = useState<Seat[]>(section.seats || []);
```

**修改后**：
```typescript
// 加载座位时，将局部坐标转换为世界坐标
const [seats, setSeats] = useState<Seat[]>(() => {
  const savedSeats = section.seats || [];
  return savedSeats.map(seat => ({
    ...seat,
    x: seat.x + sectionOrigin.x,
    y: seat.y + sectionOrigin.y,
  }));
});
```

**说明**：
- 使用函数式初始化（只执行一次）
- 将保存的局部坐标转换为世界坐标
- 便于在编辑模式中操作

#### 4. 修改保存逻辑

**修改前**：
```typescript
const handleSave = useCallback(() => {
  onSaveSeats(section.id, seats);
  onBack();
}, [section.id, seats, onSaveSeats, onBack]);
```

**修改后**：
```typescript
const handleSave = useCallback(() => {
  // 保存时，将世界坐标转换为局部坐标
  const localSeats = seats.map(seat => ({
    ...seat,
    x: seat.x - sectionOrigin.x,
    y: seat.y - sectionOrigin.y,
  }));
  onSaveSeats(section.id, localSeats);
  onBack();
}, [section.id, seats, sectionOrigin, onSaveSeats, onBack]);
```

**说明**：
- 保存前将世界坐标转换为局部坐标
- 添加 `sectionOrigin` 到依赖数组
- 确保使用最新的原点计算

## 验证测试

### 测试场景 1：基本功能

```
步骤：
1. 绘制一个 section（100, 100）到（200, 200）
2. 进入编辑模式
3. 绘制一个座位在 section 中心（150, 150）
4. 保存并返回
5. 验证：座位数据保存为局部坐标 { x: 50, y: 50 }
```

### 测试场景 2：移动后重新加载

```
步骤：
1. 绘制 section 和座位（如测试 1）
2. 保存并返回
3. 移动 section 到（300, 300）到（400, 400）
4. 再次进入编辑模式
5. ✅ 验证：座位在 section 中心（350, 350）
6. ✅ 验证：座位相对位置正确
```

### 测试场景 3：多次移动

```
步骤：
1. 绘制 section 和座位
2. 保存并返回
3. 移动 section 到位置 A
4. 进入编辑模式，验证座位位置 ✅
5. 返回，移动 section 到位置 B
6. 进入编辑模式，验证座位位置 ✅
7. 返回，移动 section 到位置 C
8. 进入编辑模式，验证座位位置 ✅
```

### 测试场景 4：编辑后移动

```
步骤：
1. 绘制 section 和座位
2. 保存并返回
3. 移动 section
4. 进入编辑模式
5. 添加更多座位
6. 保存并返回
7. 再次移动 section
8. 进入编辑模式
9. ✅ 验证：所有座位（新旧）都正确跟随
```

### 测试场景 5：矩阵座位

```
步骤：
1. 绘制 section
2. 使用矩阵工具绘制 5×10 矩阵（50个座位）
3. 保存并返回
4. 移动 section
5. 进入编辑模式
6. ✅ 验证：所有 50 个座位都正确跟随
7. ✅ 验证：矩阵结构保持完整
```

## 技术要点

### 1. 坐标系统选择

**为什么使用局部坐标存储？**

优点：
- ✅ 座位位置相对于 section 固定
- ✅ 移动 section 时，座位自动跟随
- ✅ 旋转 section 时，座位保持相对位置
- ✅ 缩放 section 时，座位保持相对位置
- ✅ 便于导入导出（位置独立）

缺点：
- ❌ 需要坐标转换（加载和保存时）
- ❌ 增加一点计算开销

**为什么编辑时使用世界坐标？**

优点：
- ✅ 与主画布坐标系统一致
- ✅ 便于绘制和操作
- ✅ 无需实时转换
- ✅ 性能更好

缺点：
- ❌ 需要在保存/加载时转换

### 2. 原点定义

**为什么使用边界框左上角？**

```typescript
const sectionOrigin = {
  x: bbox.minX,  // 最小 x
  y: bbox.minY,  // 最小 y
};
```

优点：
- ✅ 简单明确
- ✅ 始终在 section 内或边界上
- ✅ 便于计算和理解
- ✅ 与 SVG 坐标系统一致

替代方案：
```typescript
// 方案 1：使用中心点
const sectionOrigin = {
  x: (bbox.minX + bbox.maxX) / 2,
  y: (bbox.minY + bbox.maxY) / 2,
};

// 方案 2：使用第一个顶点
const sectionOrigin = section.points[0];

// 方案 3：使用质心
const sectionOrigin = {
  x: section.points.reduce((sum, p) => sum + p.x, 0) / section.points.length,
  y: section.points.reduce((sum, p) => sum + p.y, 0) / section.points.length,
};
```

选择边界框左上角的原因：
- 最稳定（不受顶点顺序影响）
- 最直观（类似 DOM 元素的原点）
- 最简单（只需要 min 值）

### 3. 性能优化

**使用 useMemo 缓存原点**：
```typescript
const sectionOrigin = useMemo(() => {
  const bbox = getBoundingBox(section.points);
  return { x: bbox.minX, y: bbox.minY };
}, [section.points]);
```

优点：
- 只在 `section.points` 变化时重新计算
- 避免每次渲染都计算
- 减少不必要的计算

**函数式初始化 state**：
```typescript
const [seats, setSeats] = useState(() => {
  // 只执行一次
  return savedSeats.map(seat => ({
    ...seat,
    x: seat.x + sectionOrigin.x,
    y: seat.y + sectionOrigin.y,
  }));
});
```

优点：
- 初始化函数只执行一次
- 避免每次渲染都转换坐标
- 提升性能

### 4. 数据一致性

**保存时转换**：
```typescript
const localSeats = seats.map(seat => ({
  ...seat,
  x: seat.x - sectionOrigin.x,
  y: seat.y - sectionOrigin.y,
}));
```

**加载时转换**：
```typescript
const worldSeats = savedSeats.map(seat => ({
  ...seat,
  x: seat.x + sectionOrigin.x,
  y: seat.y + sectionOrigin.y,
}));
```

**互逆性验证**：
```typescript
// 原始座位（世界坐标）
const original = { x: 150, y: 150 };

// 保存（世界 → 局部）
const local = {
  x: original.x - sectionOrigin.x,  // 150 - 100 = 50
  y: original.y - sectionOrigin.y,  // 150 - 100 = 50
};

// 加载（局部 → 世界）
const restored = {
  x: local.x + sectionOrigin.x,  // 50 + 100 = 150
  y: local.y + sectionOrigin.y,  // 50 + 100 = 150
};

// 验证
console.assert(restored.x === original.x);  // ✅
console.assert(restored.y === original.y);  // ✅
```

## 兼容性问题

### 旧数据迁移

⚠️ **重要**：此修复会影响已保存的座位数据

**问题**：
- 旧版本：座位坐标是世界坐标
- 新版本：座位坐标是局部坐标
- 如果直接升级：旧数据会被当作局部坐标加载，导致位置错误

**检测旧数据**：
```typescript
const isOldData = (seats: Seat[], sectionBbox: BoundingBox): boolean => {
  const sectionWidth = sectionBbox.maxX - sectionBbox.minX;
  const sectionHeight = sectionBbox.maxY - sectionBbox.minY;
  
  // 如果座位坐标远大于 section 尺寸，可能是旧的世界坐标
  return seats.some(seat => 
    Math.abs(seat.x) > sectionWidth * 2 || 
    Math.abs(seat.y) > sectionHeight * 2
  );
};
```

**迁移方案**：
```typescript
const migrateSeats = (
  seats: Seat[], 
  sectionOrigin: Point, 
  sectionBbox: BoundingBox
): Seat[] => {
  if (isOldData(seats, sectionBbox)) {
    // 旧数据：世界坐标 → 局部坐标
    return seats.map(seat => ({
      ...seat,
      x: seat.x - sectionOrigin.x,
      y: seat.y - sectionOrigin.y,
    }));
  }
  
  // 新数据：已经是局部坐标，无需转换
  return seats;
};
```

**使用迁移**：
```typescript
const [seats, setSeats] = useState(() => {
  const savedSeats = section.seats || [];
  const bbox = getBoundingBox(section.points);
  
  // 迁移旧数据
  const migratedSeats = migrateSeats(savedSeats, sectionOrigin, bbox);
  
  // 加载（局部 → 世界）
  return migratedSeats.map(seat => ({
    ...seat,
    x: seat.x + sectionOrigin.x,
    y: seat.y + sectionOrigin.y,
  }));
});
```

### 向后兼容性

**当前实现**：
- ✅ 新数据：使用局部坐标，正常工作
- ⚠️ 旧数据：需要迁移（可选）

**建议**：
1. 如果是新项目：直接使用新版本
2. 如果有旧数据：
   - 方案 A：手动迁移数据
   - 方案 B：实现自动迁移逻辑
   - 方案 C：清空旧数据，重新绘制

## 未来扩展

### 1. Section 旋转支持

当前实现已经为 section 旋转做好准备：

```typescript
// 保存时：世界坐标 → 局部坐标（相对于原点）
// 加载时：局部坐标 → 世界坐标（根据当前原点）

// 如果 section 旋转了，只需要在转换时考虑旋转角度
const rotatedSeat = rotatePoint(localSeat, sectionCenter, sectionAngle);
```

### 2. Section 缩放支持

如果需要支持 section 缩放：

```typescript
// 保存时：归一化坐标（0-1）
const normalizedSeat = {
  x: (seat.x - bbox.minX) / (bbox.maxX - bbox.minX),
  y: (seat.y - bbox.minY) / (bbox.maxY - bbox.minY),
};

// 加载时：反归一化
const worldSeat = {
  x: bbox.minX + normalizedSeat.x * (bbox.maxX - bbox.minX),
  y: bbox.minY + normalizedSeat.y * (bbox.maxY - bbox.minY),
};
```

### 3. 座位模板

基于局部坐标，可以实现座位模板：

```typescript
// 定义模板（局部坐标）
const template = {
  name: '标准剧院布局',
  seats: [
    { x: 0, y: 0, row: 'A', number: 1 },
    { x: 50, y: 0, row: 'A', number: 2 },
    // ...
  ],
};

// 应用到任意 section
const appliedSeats = template.seats.map(seat => ({
  ...seat,
  x: seat.x + sectionOrigin.x,
  y: seat.y + sectionOrigin.y,
}));
```

## 总结

这次修复解决了座位位置不跟随 section 移动的问题，核心是将座位坐标从世界坐标系改为局部坐标系存储。

**关键改动**：
1. 计算 section 原点（边界框左上角）
2. 加载时：局部坐标 → 世界坐标
3. 保存时：世界坐标 → 局部坐标

**修复效果**：
- ✅ 座位位置相对于 section 固定
- ✅ 移动 section 时，座位自动跟随
- ✅ 为未来的旋转/缩放功能做好准备

**技术收获**：
- 坐标系统设计要考虑相对关系
- 数据存储要选择合适的坐标系
- 坐标转换要在合适的时机进行
- 性能优化要使用缓存机制

这是一个典型的"坐标系统设计"问题，通过正确的坐标转换，实现了座位和 section 的关联。
