# SVG 分层架构方案

> 可直接落地的标准编辑器结构

---

## 一、SVG 顶层结构

```svg
<svg class="designer-root">

  <!-- 1. 背景层（不可交互） -->
  <g id="background-layer"></g>

  <!-- 2. 视口层（唯一做 transform 的地方） -->
  <g id="viewport-layer">

    <!-- section 层 -->
    <g id="section-layer"></g>

    <!-- seat 层 -->
    <g id="seat-layer"></g>

    <!-- overlay 层（选中框 / hover） -->
    <g id="overlay-layer"></g>

  </g>

</svg>
```

⚠️ **核心原则**：只有 `viewport-layer` 允许做 transform，其他层绝对不要单独 scale。

---

## 二、为什么必须这样分层？

因为你要解决 5 个问题：

1. 无限缩放
2. 无限拖动
3. 背景 SVG 不污染数据
4. 选中框不被缩放影响
5. 命中检测精确

---

## 三、Transform 的应用

正确的 transform 应该只存在一处：

```javascript
// 推荐：使用 matrix 格式 (参考 seats.io)
viewport.setAttribute(
  'transform',
  `matrix(${scale},0,0,${scale},${offsetX},${offsetY})`
)

// 或者：使用 translate + scale (可读性更好，但性能略差)
viewport.setAttribute(
  'transform',
  `translate(${offsetX}, ${offsetY}) scale(${scale})`
)
```

**为什么推荐 matrix？**

1. **性能更好**：浏览器直接使用矩阵，无需解析多个函数
2. **seats.io 标准**：工业级编辑器的选择
3. **减少字符串解析**：单一函数调用

**matrix 参数说明**：
```
matrix(a, b, c, d, e, f)
- a, d: 缩放 (scale)
- b, c: 倾斜 (通常为 0)
- e, f: 平移 (offsetX, offsetY)
```

❌ **不要这样做**：

- seat 上单独加 transform
- section 上单独加 transform
- background 上单独加 transform

> 后期必炸。

---

## 四、背景 SVG 处理

用户上传 SVG 底图的正确做法：

```svg
<g id="background-layer">
   <image href="user.svg" />
</g>
```

或者直接 `innerHTML` 插入 SVG。

**背景层必须满足**：

- 不参与 selection
- `pointer-events: none`
- 不允许修改

**否则你会陷入**：

- SVG DOM 混乱
- 数据与视图耦合
- hit test 失控

---

## 五、Section Layer 设计

每个 section：

```svg
<g class="section" data-id="xxx">
   <polygon />
   <text />
</g>
```

⚠️ **不要给 section 加 transform**。

Section 的移动应该：

```
修改 world 坐标 → 重新计算 points
```

而不是：

```svg
<g transform="translate(...)">  <!-- ❌ 编辑器常见大坑 -->
```

---

## 六、Seat Layer 设计

Seat 建议不要太复杂：

```svg
<g class="seat" data-id="s1">
   <circle />
   <text />
</g>
```

同样：

- 不单独 transform
- 坐标直接用 world 坐标渲染

---

## 七、Overlay Layer 为什么必须单独存在？

因为：**选中框不应该跟随 scale 改变线宽**。

如果 overlay 在 viewport 内：

```
scale 2 倍 → 选中线宽也 2 倍 ❌
```

### 解决方案

**方案 A（推荐）**

Overlay 放在 viewport 内，但使用：

```svg
vector-effect="non-scaling-stroke"
```

保持线宽不变。

**方案 B**

Overlay 放在 viewport 外，手动做坐标转换。

> 更复杂，不建议。

---

## 八、常见错误架构（千万别这样）

### ❌ 错误 1：每个 section 独立 transform

后果：

- 坐标系统变嵌套
- hit test 崩
- seat 批量移动混乱

### ❌ 错误 2：seat 使用相对 section 坐标

看似合理：

```javascript
seat.x 相对于 section.x
```

但实际会导致：

- section 移动要级联更新所有 seat
- 性能问题
- 数据复杂

**正确方式**：

> 所有 seat 仍然使用 world 坐标，section 只是逻辑分组。

### ❌ 错误 3：背景 SVG 和编辑数据混在一起

很多人直接修改用户上传的 SVG。

> ⚠️ 这是架构级错误。

编辑数据必须独立于背景 SVG。

---

## 九、SVG vs Canvas 在架构上的差异

| 场景 | 推荐方案 |
|------|----------|
| seat 数量 < 3000 | SVG 架构没问题 |
| seat 数量 > 5000 | SVG DOM 会卡 |

seat 数量多时，你需要：

- 保留 scene graph
- 替换 render layer 为 Canvas

也就是说：**架构必须保证 render 层可替换**。

---

## 十、检查清单

你当前的 SVG 结构是否满足：

- [ ] 只有一个 transform 根节点
- [ ] seat 不使用 transform
- [ ] section 不使用 transform
- [ ] overlay 独立
- [ ] 背景设置 `pointer-events: none`

> 如果不满足第一条，先改。

---

## 十一、工业级建议

**不要把 SVG 当 DOM**。

把它当：**纯渲染引擎**。

真正的数据结构应该是：

```javascript
scene = {
  sections: Map,
  seats: Map,
}
```

然后：

```javascript
render(scene, viewport)
```

永远单向流。

---

## 十二、seats.io 的设计精髓

参考 seats.io 的实际实现，我们总结出以下关键设计：

### 1. 透明交互层技术

```svg
<!-- 视觉层 -->
<circle r="10" fill="#3b82f6" />

<!-- 交互层 (扩大点击区域 50%) -->
<circle r="15" fill="black" opacity="0" cursor="pointer" pointer-events="auto" />
```

**作用**：
- 解决小元素难以点击的问题
- 不影响视觉效果
- 独立控制 cursor 样式

### 2. 状态分层渲染

```svg
<!-- 预渲染所有状态层 -->
<g class="seat">
  <g class="normal-state"></g>
  <g class="hover-state" style="display: none;"></g>
  <g class="selected-state" style="display: none;"></g>
</g>
```

**优势**：
- 状态切换只需修改 `display` 属性
- 性能更好（避免频繁修改多个属性）
- 动画更流畅（CSS transition）

### 3. 多层边框效果

```svg
<!-- 白色外边框 (提高对比度) -->
<rect stroke="white" stroke-width="1.78" />

<!-- 彩色内边框 -->
<rect stroke="#0088ff" stroke-width="0.89" />
```

**作用**：
- 创建多层视觉效果
- 提高对比度和可读性
- 适应不同背景色

### 4. vector-effect 的正确使用

```svg
<!-- ❌ 错误：手动反缩放 + vector-effect (冗余) -->
<path stroke-width="2 / scale" vector-effect="non-scaling-stroke" />

<!-- ✅ 正确：直接用固定值 -->
<path stroke-width="2" vector-effect="non-scaling-stroke" />
```

**原理**：`vector-effect="non-scaling-stroke"` 会自动保持线宽不变。

---

## 十三、完整的座位渲染结构

参考 seats.io，座位应该包含以下层次：

```svg
<g class="seat" data-id="s1">
  <!-- 1. 选中高亮 (粗边框) -->
  <circle cx="100" cy="100" r="12" fill="none" stroke="#2563eb" stroke-width="4" />
  
  <!-- 2. 座位主体 -->
  <circle cx="100" cy="100" r="10" fill="#3b82f6" stroke="white" stroke-width="2" />
  
  <!-- 3. 标签 -->
  <text x="100" y="100" pointer-events="none">A1</text>
  
  <!-- 4. 透明交互层 -->
  <circle cx="100" cy="100" r="15" fill="black" opacity="0" cursor="pointer" pointer-events="auto" />
  
  <!-- 5. hover 状态层 (默认隐藏) -->
  <circle cx="100" cy="100" r="11" fill="none" stroke="#60a5fa" stroke-width="2" style="display: none;" />
</g>
```

**关键点**：
- 所有元素直接使用 world 坐标 (cx/cy)
- 不使用 transform
- 交互层比视觉层大 50%
- 状态层通过 display 控制显示/隐藏

---

## 十四、架构优化清单

基于 seats.io 的分析，我们的架构已优化：

- [x] 只有一个 transform 根节点 (viewport-layer)
- [x] seat 不使用 transform，直接用 world 坐标
- [x] section 不使用 transform
- [x] overlay 使用 vector-effect="non-scaling-stroke"
- [x] 背景设置 pointer-events: none
- [x] 座位有独立的透明交互层
- [x] overlay 层的 stroke-width 使用固定值

待实现：
- [ ] 座位使用状态分层渲染
- [ ] 座位有多层边框效果
- [ ] 选中状态在座位自身渲染，而不是 overlay 层
