# 问题修复记录

## [2026-02-26] Delete 键事件冲突

### 🐛 问题描述

**现象**：
在区域编辑模式内按 Delete 键删除座位时，发生以下问题：
1. 退出了区域编辑模式
2. 正在编辑的区域被删除
3. 所有座位数据丢失

**复现步骤**：
```
1. 双击进入区域编辑模式
2. 完成校准
3. 绘制一些座位
4. 选中座位
5. 按 Delete 键
6. ❌ 区域被删除并退出编辑模式
```

### 🔍 问题分析

**根本原因**：事件冒泡导致键盘事件被多个监听器处理

```
用户按 Delete 键
    ↓
EditModeCanvas 监听器处理（删除座位）✅
    ↓
事件继续冒泡
    ↓
App.tsx 监听器处理（删除区域）❌ ← 问题所在
```

**代码分析**：

```typescript
// App.tsx 第 394 行（修复前）
if ((e.key === 'Delete' || e.key === 'Backspace') 
    && selectedIds.size > 0 
    && activeTool === 'select' 
    && !isDrawing) {
  // 删除区域 - 没有检查是否在编辑模式内！
  setSections(prev => prev.filter(s => !selectedIds.has(s.id)));
}
```

### ✅ 解决方案

#### 方案 1：主画布添加模式检查（已采用）

在主画布的 Delete 键监听器中添加 `!sectionEditState.isActive` 检查：

```typescript
// App.tsx 第 394 行（修复后）
if ((e.key === 'Delete' || e.key === 'Backspace') 
    && selectedIds.size > 0 
    && activeTool === 'select' 
    && !isDrawing 
    && !sectionEditState.isActive) {  // ← 新增检查
  e.preventDefault();
  setSections(prev => prev.filter(s => !selectedIds.has(s.id)));
  setSelectedIds(new Set());
  setSelectedSectionId(null);
}
```

**优点**：
- 简单直接
- 不影响其他功能
- 性能无损耗

#### 方案 2：EditModeCanvas 阻止冒泡（未采用）

在 EditModeCanvas 中使用 `e.stopPropagation()`：

```typescript
// 未采用，因为方案 1 更清晰
if (e.code === 'Delete' || e.code === 'Backspace') {
  if (selectedSeatIds.size > 0) {
    e.preventDefault();
    e.stopPropagation();  // 阻止冒泡
    onDeleteSeats(Array.from(selectedSeatIds));
  }
}
```

**缺点**：
- 可能影响其他事件处理
- 不够清晰

### 🔧 相关修复

#### ESC 键冲突修复

**问题**：编辑模式下按 ESC 键会退出整个模态框

**修复**：在 SectionEditModal 中添加阶段检查

```typescript
// SectionEditModal.tsx（修复后）
if (e.key === 'Escape' && state.phase === 'calibrating') {
  // 只在校准模式下退出模态框
  // 编辑模式下由 EditModeCanvas 处理
  onExit();
}
```

### 📝 修改的文件

1. **`app/src/App.tsx`**
   - 第 394 行：添加 `!sectionEditState.isActive` 检查
   - 确保只在主画布模式下响应 Delete 键

2. **`app/src/components/section-edit/SectionEditModal.tsx`**
   - 第 43 行：添加 `state.phase === 'calibrating'` 检查
   - 确保 ESC 键只在校准模式下退出模态框

### ✅ 验证测试

#### 测试 1：编辑模式内删除座位
```
1. 进入区域编辑模式 ✓
2. 绘制座位 ✓
3. 选中座位 ✓
4. 按 Delete 键 ✓
5. 预期：只删除座位，不退出编辑模式 ✅
6. 预期：区域不被删除 ✅
```

#### 测试 2：主画布删除区域
```
1. 在主画布选中区域 ✓
2. 按 Delete 键 ✓
3. 预期：区域被删除 ✅
```

#### 测试 3：编辑模式 ESC 键
```
1. 进入区域编辑模式 ✓
2. 按 1 键开始绘制 ✓
3. 按 ESC 键 ✓
4. 预期：取消绘制，切换到选择工具 ✅
5. 预期：不退出编辑模式 ✅
```

#### 测试 4：校准模式 ESC 键
```
1. 进入区域编辑模式（校准阶段）✓
2. 按 ESC 键 ✓
3. 预期：退出整个模态框 ✅
```

### 📊 影响范围

| 场景 | 修复前 | 修复后 |
|------|--------|--------|
| 编辑模式 + Delete | ❌ 删除区域并退出 | ✅ 只删除座位 |
| 主画布 + Delete | ✅ 删除区域 | ✅ 删除区域 |
| 编辑模式 + ESC | ❌ 退出模态框 | ✅ 取消绘制/切换工具 |
| 校准模式 + ESC | ✅ 退出模态框 | ✅ 退出模态框 |

### 🎯 经验教训

1. **键盘事件需要模式检查**：全局键盘监听器必须检查当前模式
2. **事件优先级**：子组件的事件处理应该优先于父组件
3. **使用 capture 阶段**：`addEventListener(..., true)` 可以更早捕获事件
4. **明确的状态检查**：使用 `isActive`、`phase` 等状态明确区分模式

### 🔄 最佳实践

```typescript
// ✅ 推荐：明确的模式检查
if (e.key === 'Delete' && !isInEditMode) {
  // 主画布逻辑
}

// ❌ 不推荐：依赖事件冒泡控制
if (e.key === 'Delete') {
  e.stopPropagation();  // 不够清晰
}
```

---

*问题发现: 2026-02-26*
*问题修复: 2026-02-26*
*修复版本: v1.2.1*
