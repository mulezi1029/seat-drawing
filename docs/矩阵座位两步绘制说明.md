# 矩阵座位两步绘制功能说明

## 概述

矩阵座位工具采用与 seats.io 一致的两步绘制交互方式，让用户能够更直观、更精确地绘制矩形座位布局。

## 交互流程

### 第一步：绘制第一排

**目的**：定义座位的方向和每排的座位数量

**操作步骤**：
```
1. 按 2 键切换到矩阵座位工具
2. 在画布上按住鼠标左键
3. 拖拽到目标位置（定义方向和长度）
4. 释放鼠标完成第一排
```

**实时预览**：
- 🔵 蓝色正方形座位：沿拖拽方向均匀分布
- 📏 蓝色虚线：连接起点和终点
- 🏷️ 黑色数量标签：显示座位数量

**计算逻辑**：
```typescript
// 根据拖拽距离计算座位数量
const distance = Math.hypot(dx, dy);
const cellWidth = seatVisual.size + seatVisual.gapX;
const seatCount = Math.max(1, Math.round(distance / cellWidth));

// 计算旋转角度
const angle = Math.atan2(dy, dx);

// 沿拖拽方向均匀分布座位
for (let i = 0; i < seatCount; i++) {
  const t = seatCount === 1 ? 0 : i / (seatCount - 1);
  seats.push({
    x: startX + dx * t,
    y: startY + dy * t,
    angle: angle * 180 / Math.PI,
  });
}
```

**完成第一步后**：
- 第一排座位固定在画布上
- 座位显示为白色（正常状态）
- 进入第二步绘制状态

### 第二步：垂直扩展为矩阵

**目的**：在垂直方向扩展，形成多排座位

**操作步骤**：
```
1. 第一排已固定在画布上
2. 在任意位置按住鼠标左键
3. 拖拽（系统自动计算垂直方向）
4. 释放鼠标完成矩阵绘制
```

**实时预览**：
- 🔷 第一排：深蓝色 `rgba(59, 130, 246, 0.5)`（已固定）
- 🔹 新增行：浅蓝色 `rgba(59, 130, 246, 0.3)`（预览）
- 📊 矩阵尺寸标签：显示 "行数 × 列数"（如 "5 × 10"）

**计算逻辑**：
```typescript
// 1. 计算第一排的方向向量
const firstSeat = matrixFirstRow[0];
const lastSeat = matrixFirstRow[matrixFirstRow.length - 1];
const rowDx = lastSeat.x - firstSeat.x;
const rowDy = lastSeat.y - firstSeat.y;
const rowLength = Math.sqrt(rowDx * rowDx + rowDy * rowDy);

// 2. 计算单位方向向量
const rowUnitX = rowDx / rowLength;
const rowUnitY = rowDy / rowLength;

// 3. 计算垂直方向单位向量（逆时针旋转90度）
const perpUnitX = -rowUnitY;
const perpUnitY = rowUnitX;

// 4. 计算拖拽点到第一排的垂直距离
const dragDx = currentPoint.x - firstSeat.x;
const dragDy = currentPoint.y - firstSeat.y;
const perpDistance = Math.abs(dragDx * perpUnitX + dragDy * perpUnitY);

// 5. 根据垂直距离计算行数
const cellHeight = seatVisual.size + seatVisual.gapY;
const rowCount = Math.max(1, Math.round(perpDistance / cellHeight));

// 6. 生成多排座位
for (let r = 1; r < rowCount; r++) {
  for (let c = 0; c < matrixFirstRow.length; c++) {
    const baseSeat = matrixFirstRow[c];
    newSeats.push({
      x: baseSeat.x + perpUnitX * cellHeight * r,
      y: baseSeat.y + perpUnitY * cellHeight * r,
      angle: baseSeat.angle,  // 保持第一排的角度
    });
  }
}
```

**完成第二步后**：
- 所有座位固定在画布上
- 座位显示为白色（正常状态）
- 矩阵绘制状态重置
- 可以开始新的绘制

## 视觉反馈

### 第一步预览

```
起点 ●━━━━━━━━━━━━━━━━━━━━● 终点
     ○  ○  ○  ○  ○  ○  ○  ○
          [  8  ]  ← 数量标签
```

**元素说明**：
- **蓝色虚线**：连接起点和终点
- **蓝色正方形**：预览座位位置
- **黑色标签**：显示座位数量
- **自动旋转**：座位对齐拖拽方向

### 第二步预览

```
第一排（深蓝）  ■ ■ ■ ■ ■ ■ ■ ■
                ↓ 垂直方向
第二排（浅蓝）  □ □ □ □ □ □ □ □
第三排（浅蓝）  □ □ □ □ □ □ □ □
第四排（浅蓝）  □ □ □ □ □ □ □ □
第五排（浅蓝）  □ □ □ □ □ □ □ □

              [ 5 × 8 ]  ← 尺寸标签
```

**元素说明**：
- **深蓝色正方形**：第一排（已固定）
- **浅蓝色正方形**：新增行（预览）
- **黑色标签**：显示矩阵尺寸

## 状态管理

### 状态变量

```typescript
// 第一排座位数据（null 表示第一步，非 null 表示第二步）
const [matrixFirstRow, setMatrixFirstRow] = useState<Seat[] | null>(null);

// 绘制状态（两步都需要）
const [drawStart, setDrawStart] = useState<Point | null>(null);
const [drawCurrent, setDrawCurrent] = useState<Point | null>(null);
const [isDrawing, setIsDrawing] = useState(false);
```

### 状态转换

```
初始状态
  ↓ 按 2 键
矩阵工具激活（matrixFirstRow = null）
  ↓ mouseDown
第一步绘制中（isDrawing = true）
  ↓ mouseUp
第一步完成（matrixFirstRow = firstRowSeats）
  ↓ mouseDown
第二步绘制中（isDrawing = true）
  ↓ mouseUp
第二步完成（matrixFirstRow = null）
  ↓
初始状态
```

### 状态重置

**触发条件**：
1. 完成第二步绘制
2. 按 ESC 键取消
3. 切换到其他工具

**重置操作**：
```typescript
// 删除第一排座位（如果存在）
if (matrixFirstRow) {
  onDeleteSeats(matrixFirstRow.map(s => s.id));
}

// 重置状态
setMatrixFirstRow(null);
setIsDrawing(false);
setDrawStart(null);
setDrawCurrent(null);
```

## 数学原理

### 垂直方向计算

**问题**：如何计算垂直于第一排的方向？

**解决方案**：向量旋转

```typescript
// 第一排方向向量
const rowVector = { x: rowDx, y: rowDy };

// 逆时针旋转 90 度
// 旋转矩阵: [cos(90°)  -sin(90°)]   [0  -1]
//          [sin(90°)   cos(90°)] = [1   0]
const perpVector = {
  x: -rowVector.y,  // 新 x = -旧 y
  y: rowVector.x,   // 新 y = 旧 x
};
```

**示例**：
```
第一排方向: (1, 0) → 水平向右
垂直方向:   (0, 1) → 垂直向下

第一排方向: (1, 1) → 右下 45°
垂直方向:   (-1, 1) → 左下 45°
```

### 垂直距离计算

**问题**：如何计算拖拽点到第一排的垂直距离？

**解决方案**：向量投影

```typescript
// 拖拽点相对于第一个座位的向量
const dragVector = {
  x: dragPoint.x - firstSeat.x,
  y: dragPoint.y - firstSeat.y,
};

// 投影到垂直方向（点积）
const perpDistance = Math.abs(
  dragVector.x * perpUnitX + dragVector.y * perpUnitY
);
```

**几何意义**：
```
        dragPoint ●
                 /|
                / |
               /  | perpDistance
              /   |
             /    |
firstSeat ●━━━━━━● 投影点
         ←─────→
         rowVector
```

### 座位位置计算

**问题**：如何计算新增行的座位位置？

**解决方案**：基于第一排平移

```typescript
// 第 r 行第 c 列的座位位置
const newSeat = {
  x: firstRow[c].x + perpUnitX * cellHeight * r,
  y: firstRow[c].y + perpUnitY * cellHeight * r,
  angle: firstRow[c].angle,  // 保持角度
};
```

**示例**：
```
第一排第 3 个座位: (100, 100)
垂直单位向量: (0, 1)
行间距: 50

第二排第 3 个座位: (100, 150) = (100, 100) + (0, 1) * 50 * 1
第三排第 3 个座位: (100, 200) = (100, 100) + (0, 1) * 50 * 2
```

## 使用场景

### 场景 1：标准剧院式布局

```
需求：绘制 10 排，每排 20 个座位

操作：
1. 按 2 切换到矩阵工具
2. 水平拖拽，绘制 20 个座位的第一排
3. 释放鼠标
4. 向下拖拽，扩展为 10 排
5. 释放鼠标完成

结果：10 × 20 = 200 个座位
```

### 场景 2：倾斜的 VIP 区域

```
需求：绘制倾斜 30° 的 5 排 VIP 座位，每排 8 个

操作：
1. 按 2 切换到矩阵工具
2. 斜向拖拽（约 30°），绘制 8 个座位
3. 释放鼠标
4. 垂直于第一排方向拖拽，扩展为 5 排
5. 释放鼠标完成
6. 框选所有座位，设置类型为 VIP

结果：5 × 8 = 40 个倾斜的 VIP 座位
```

### 场景 3：不规则场地适配

```
需求：在倾斜的墙边绘制座位

操作：
1. 按 2 切换到矩阵工具
2. 沿墙边方向拖拽，绘制第一排
3. 释放鼠标
4. 垂直于墙边拖拽，扩展多排
5. 释放鼠标完成

结果：自动对齐墙边的多排座位
```

## 取消操作

### 第一步取消

**触发**：在第一步绘制中按 ESC 键

**效果**：
- 取消当前拖拽
- 不创建任何座位
- 保持矩阵工具激活

**代码**：
```typescript
if (e.code === 'Escape' && isDrawing && !matrixFirstRow) {
  setIsDrawing(false);
  setDrawStart(null);
  setDrawCurrent(null);
}
```

### 第二步取消

**触发**：在第二步绘制中按 ESC 键

**效果**：
- 删除第一排座位
- 重置矩阵状态
- 回到初始状态

**代码**：
```typescript
if (e.code === 'Escape' && matrixFirstRow) {
  onDeleteSeats(matrixFirstRow.map(s => s.id));
  setMatrixFirstRow(null);
}
```

### 工具切换取消

**触发**：在第二步状态下切换到其他工具

**效果**：
- 自动删除第一排座位
- 重置矩阵状态
- 切换到新工具

**代码**：
```typescript
useEffect(() => {
  if (currentTool !== 'matrix' && matrixFirstRow) {
    onDeleteSeats(matrixFirstRow.map(s => s.id));
    setMatrixFirstRow(null);
  }
}, [currentTool, matrixFirstRow]);
```

## 与 seats.io 的一致性

### 交互流程

| 特性 | seats.io | 本实现 | 状态 |
|------|----------|--------|------|
| 两步绘制 | ✅ | ✅ | 一致 |
| 第一步定义方向 | ✅ | ✅ | 一致 |
| 第二步垂直扩展 | ✅ | ✅ | 一致 |
| 实时预览 | ✅ | ✅ | 一致 |
| 数量标签 | ✅ | ✅ | 一致 |

### 视觉反馈

| 元素 | seats.io | 本实现 | 状态 |
|------|----------|--------|------|
| 第一步蓝色座位 | ✅ | ✅ | 一致 |
| 第一步连接线 | ✅ | ✅ | 一致 |
| 第一步数量标签 | ✅ | ✅ | 一致 |
| 第二步深浅区分 | ✅ | ✅ | 一致 |
| 第二步尺寸标签 | ✅ | ✅ | 一致 |

### 功能特性

| 功能 | seats.io | 本实现 | 状态 |
|------|----------|--------|------|
| 支持任意角度 | ✅ | ✅ | 一致 |
| 自动垂直对齐 | ✅ | ✅ | 一致 |
| ESC 键取消 | ✅ | ✅ | 一致 |
| 保持旋转角度 | ✅ | ✅ | 一致 |

## 技术要点

### 1. 状态持久化

**问题**：第一排座位在第二步时需要保持在画布上

**解决方案**：
```typescript
// 第一步完成时，立即添加到画布
onAddSeats(firstRowSeats);

// 同时保存到状态，用于第二步计算
setMatrixFirstRow(firstRowSeats);
```

### 2. 避免重复添加

**问题**：第二步完成时，第一排已经在画布上了

**解决方案**：
```typescript
// 只添加新增的行（跳过第一排）
const newRows = allSeats.slice(matrixFirstRow.length);
onAddSeats(newRows);
```

### 3. 组 ID 管理

**问题**：整个矩阵应该属于同一个组

**解决方案**：
```typescript
// 第一步生成组 ID
const groupId = `group-${Date.now()}`;

// 第一步座位 ID
`seat-${groupId}-0-${col}`

// 第二步座位 ID（复用组 ID）
`seat-${groupId}-${row}-${col}`
```

### 4. 性能优化

**优化点**：
- 使用 `useMemo` 缓存预览计算
- 避免在 render 中进行复杂计算
- 使用 `useCallback` 避免重复创建函数

```typescript
const matrixPreview = useMemo(() => {
  // 复杂的预览计算
}, [isDrawing, drawStart, drawCurrent, matrixFirstRow]);
```

## 常见问题

### Q: 第二步拖拽方向有限制吗？

**A:** 没有限制。系统会自动计算拖拽点到第一排的垂直距离，无论你从哪个方向拖拽，都会在垂直方向扩展。

### Q: 如果第一步只绘制了 1 个座位怎么办？

**A:** 可以正常进入第二步。第二步会垂直于第一步的拖拽方向扩展，形成单列多排的布局。

### Q: 可以绘制单排吗（不进行第二步）？

**A:** 不建议。如果只需要单排，请使用单排工具（按 1 键）。矩阵工具设计为两步交互，第一步完成后会等待第二步。如果不想继续，按 ESC 取消。

### Q: 第二步的行数如何控制？

**A:** 行数由拖拽的垂直距离决定。拖拽距离越大，行数越多。系统会根据行间距自动计算行数。

### Q: 矩阵的旋转角度如何确定？

**A:** 旋转角度由第一步的拖拽方向决定。整个矩阵会保持第一步确定的角度。

### Q: 如果第一步绘制错了怎么办？

**A:** 按 ESC 键取消第二步，会自动删除第一排座位，然后可以重新开始绘制。

## 总结

矩阵座位两步绘制功能完全模仿 seats.io 的交互方式，提供了：

1. **直观的操作流程**：先定义方向，再定义范围
2. **清晰的视觉反馈**：实时预览，深浅区分
3. **灵活的适配能力**：支持任意角度，自动垂直对齐
4. **完善的容错机制**：ESC 取消，工具切换清理
5. **精确的数学计算**：向量旋转，投影距离

这一功能显著提升了矩形座位布局的绘制效率和精确度，使得用户能够轻松应对各种复杂的场地布局需求。
