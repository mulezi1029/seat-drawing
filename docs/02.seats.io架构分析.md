# seats.io 架构分析与优化方案

> 基于 seats.io 原生结构的深度分析

---

## 一、seats.io 核心设计原则

### 1. 统一 Transform 根节点

所有元素使用同一个 transform：

```svg
<svg>
  <!-- 所有元素共享同一个 transform (使用 matrix 格式) -->
  <g transform="matrix(1.125,0,0,1.125,-1306.385,-1260.5)">
    <image />
    <path />
    <text />
    ...
  </g>
</svg>
```

**为什么使用 matrix 而不是 translate + scale？**

```svg
<!-- ❌ 传统方式：需要解析两个函数 -->
<g transform="translate(-1306.385, -1260.5) scale(1.125)">

<!-- ✅ seats.io 方式：单一矩阵，性能更好 -->
<g transform="matrix(1.125,0,0,1.125,-1306.385,-1260.5)">
```

**matrix(a, b, c, d, e, f) 参数说明**：
- `a`: x 方向缩放
- `b`: y 方向倾斜
- `c`: x 方向倾斜
- `d`: y 方向缩放
- `e`: x 方向平移
- `f`: y 方向平移

**转换公式**：
```
translate(offsetX, offsetY) scale(scale)
↓
matrix(scale, 0, 0, scale, offsetX, offsetY)
```

**优势**：
- 坐标系统简单统一
- 缩放和平移性能最优（浏览器直接使用矩阵，无需解析多个函数）
- 避免嵌套 transform 导致的坐标混乱
- 减少字符串解析开销

---

## 二、座位的多层渲染策略

seats.io 的单个座位使用了 **10+ 层** SVG 元素：

```svg
<!-- 1. 选中高亮边框 (粗线) -->
<path stroke-width="8" stroke="rgba(0, 136, 255, 1)" />

<!-- 2. 座位主体形状 -->
<path fill="#e3e3e3" stroke="#cccccc" stroke-width="4" />

<!-- 3. 座位标签 -->
<text pointer-events="none">?</text>

<!-- 4. 透明交互层 (关键!) -->
<path fill="black" opacity="0" />

<!-- 5. 白色边框高亮 -->
<rect stroke="white" stroke-width="1.78" />

<!-- 6. 蓝色边框 -->
<rect stroke="rgba(0, 136, 255, 1)" stroke-width="0.89" />

<!-- 7. 选中线 -->
<path stroke-width="1.33" />

<!-- 8. 透明命中区域 -->
<rect opacity="0" cursor="move" pointer-events="auto" />

<!-- 9. 连接线和圆点 -->
<path />
<circle fill="#0087ff" />

<!-- 10. hover 状态层 (默认隐藏) -->
<path style="display: none;" />

<!-- 11. 编辑控制点 (默认隐藏) -->
<circle style="display: none;" />
<text style="display: none;">✻</text>
```

### 为什么这样设计？

#### 1. **透明交互层技术**

```svg
<rect 
  fill="black" 
  opacity="0" 
  cursor="pointer" 
  pointer-events="auto" 
/>
```

**作用**：
- 扩大点击区域（比视觉区域大 20-30%）
- 不影响视觉效果
- 独立控制 cursor 样式
- 解决小元素难以点击的问题

**对比我们的实现**：
```typescript
// ❌ 旧方案：点击区域 = 视觉区域
<circle r="10" />

// ✅ 新方案：点击区域 > 视觉区域
<circle r="10" />  <!-- 视觉 -->
<circle r="15" opacity="0" />  <!-- 交互 -->
```

#### 2. **状态分层渲染**

seats.io 不是动态修改属性，而是：

```svg
<!-- 预渲染所有状态层 -->
<path class="normal-state" />
<path class="hover-state" style="display: none;" />
<path class="selected-state" style="display: none;" />
```

**优势**：
- 状态切换只需修改 `display` 属性
- 性能更好（避免频繁修改多个属性）
- 动画更流畅（CSS transition）

**对比我们的实现**：
```typescript
// ❌ 旧方案：动态修改多个属性
circle.setAttribute('fill', selected ? '#3b82f6' : '#e3e3e3');
circle.setAttribute('stroke', selected ? '#2563eb' : '#cccccc');
circle.setAttribute('stroke-width', selected ? '3' : '2');

// ✅ 新方案：切换显示
normalLayer.style.display = selected ? 'none' : 'block';
selectedLayer.style.display = selected ? 'block' : 'none';
```

#### 3. **多层边框效果**

```svg
<!-- 白色外边框 -->
<rect stroke="white" stroke-width="1.78" />

<!-- 蓝色内边框 -->
<rect stroke="rgba(0, 136, 255, 1)" stroke-width="0.89" />
```

**作用**：
- 创建多层视觉效果
- 提高对比度和可读性
- 适应不同背景色

---

## 三、背景图片处理

```svg
<image 
  width="485" 
  height="442" 
  xlink:href="https://..." 
  opacity="0.8"
  transform="matrix(...)"
/>
```

**关键点**：
1. 使用 `<image>` 标签而不是 CSS background
2. `opacity="0.8"` 半透明，不干扰编辑
3. 与其他元素共享同一个 transform
4. 不设置 `pointer-events`（默认不可交互）

---

## 四、我们的架构优化

### 优化 1: 移除座位的 transform

**❌ 旧代码**：
```typescript
group.setAttribute('transform', `translate(${seat.x}, ${seat.y})`);
circle.setAttribute('r', '10');
```

**✅ 新代码**：
```typescript
// 不使用 transform，直接用 world 坐标
circle.setAttribute('cx', String(seat.x));
circle.setAttribute('cy', String(seat.y));
circle.setAttribute('r', '10');
```

**优势**：
- 坐标系统更简单
- 避免嵌套 transform
- 性能更好（减少矩阵计算）

### 优化 2: 添加透明交互层

**✅ 新代码**：
```typescript
// 1. 视觉层
const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
circle.setAttribute('cx', String(seat.x));
circle.setAttribute('cy', String(seat.y));
circle.setAttribute('r', '10');
circle.setAttribute('fill', '#3b82f6');

// 2. 交互层 (扩大点击区域)
const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
hitArea.setAttribute('cx', String(seat.x));
hitArea.setAttribute('cy', String(seat.y));
hitArea.setAttribute('r', '15');  // 比视觉层大 50%
hitArea.setAttribute('fill', 'black');
hitArea.setAttribute('opacity', '0');
hitArea.setAttribute('cursor', 'pointer');
hitArea.setAttribute('pointer-events', 'auto');
```

### 优化 3: 简化 overlay 层的 stroke-width

**❌ 旧代码**：
```typescript
// 手动反缩放 (冗余)
polygon.setAttribute('stroke-width', String(2 / scale));
polygon.setAttribute('vector-effect', 'non-scaling-stroke');
```

**✅ 新代码**：
```typescript
// 使用 vector-effect 后，直接用固定值
polygon.setAttribute('stroke-width', '2');
polygon.setAttribute('vector-effect', 'non-scaling-stroke');
```

**原理**：
- `vector-effect="non-scaling-stroke"` 会自动保持线宽不变
- 不需要手动计算 `1 / scale`

---

## 五、完整的座位渲染结构

参考 seats.io，我们的座位应该这样渲染：

```typescript
function renderSeat(seat: Seat, isSelected: boolean, isHovered: boolean) {
  const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  group.setAttribute('class', 'seat');
  group.setAttribute('data-id', seat.id);

  // 1. 选中高亮 (粗边框)
  if (isSelected) {
    const highlight = createCircle(seat.x, seat.y, 12);
    highlight.setAttribute('fill', 'none');
    highlight.setAttribute('stroke', '#2563eb');
    highlight.setAttribute('stroke-width', '4');
    group.appendChild(highlight);
  }

  // 2. 座位主体
  const circle = createCircle(seat.x, seat.y, 10);
  circle.setAttribute('fill', '#3b82f6');
  circle.setAttribute('stroke', 'white');
  circle.setAttribute('stroke-width', '2');
  group.appendChild(circle);

  // 3. 标签
  const text = createText(seat.x, seat.y, `${seat.row}${seat.number}`);
  text.setAttribute('pointer-events', 'none');
  group.appendChild(text);

  // 4. 透明交互层
  const hitArea = createCircle(seat.x, seat.y, 15);
  hitArea.setAttribute('fill', 'black');
  hitArea.setAttribute('opacity', '0');
  hitArea.setAttribute('cursor', 'pointer');
  hitArea.setAttribute('pointer-events', 'auto');
  group.appendChild(hitArea);

  // 5. hover 状态层 (默认隐藏)
  const hoverLayer = createCircle(seat.x, seat.y, 11);
  hoverLayer.setAttribute('fill', 'none');
  hoverLayer.setAttribute('stroke', '#60a5fa');
  hoverLayer.setAttribute('stroke-width', '2');
  hoverLayer.style.display = isHovered ? 'block' : 'none';
  group.appendChild(hoverLayer);

  return group;
}
```

---

## 六、性能优化建议

### 1. 使用 DocumentFragment 批量插入

```typescript
// ❌ 旧方案：逐个插入
seats.forEach(seat => {
  const element = renderSeat(seat);
  seatLayer.appendChild(element);
});

// ✅ 新方案：批量插入
const fragment = document.createDocumentFragment();
seats.forEach(seat => {
  const element = renderSeat(seat);
  fragment.appendChild(element);
});
seatLayer.appendChild(fragment);
```

### 2. 使用 `will-change` 优化动画

```typescript
viewport.style.willChange = 'transform';
```

### 3. 座位数量超过 5000 时考虑虚拟化

```typescript
// 只渲染视口内的座位
function getVisibleSeats(viewport: ViewportState): Seat[] {
  const bounds = getViewportBounds(viewport);
  return seats.filter(seat => isInBounds(seat, bounds));
}
```

---

## 七、架构检查清单

对比 seats.io，我们的架构应该满足：

- [x] 只有一个 transform 根节点 (viewport-layer)
- [x] seat 不使用 transform，直接用 world 坐标
- [x] section 不使用 transform
- [x] overlay 使用 vector-effect="non-scaling-stroke"
- [x] 背景设置 pointer-events: none
- [x] 座位有独立的透明交互层
- [ ] 座位使用状态分层渲染 (待实现)
- [ ] 座位有多层边框效果 (待实现)

---

## 八、下一步优化方向

### 1. 实现状态分层渲染

将座位的不同状态预渲染为独立层：

```typescript
interface SeatLayers {
  normal: SVGElement;
  hover: SVGElement;
  selected: SVGElement;
  disabled: SVGElement;
}
```

### 2. 添加多层边框效果

参考 seats.io 的白色外边框 + 彩色内边框：

```typescript
// 白色外边框 (提高对比度)
const outerStroke = createCircle(seat.x, seat.y, 11);
outerStroke.setAttribute('fill', 'none');
outerStroke.setAttribute('stroke', 'white');
outerStroke.setAttribute('stroke-width', '2');

// 彩色内边框
const innerStroke = createCircle(seat.x, seat.y, 10.5);
innerStroke.setAttribute('fill', 'none');
innerStroke.setAttribute('stroke', '#2563eb');
innerStroke.setAttribute('stroke-width', '1');
```

### 3. 优化选中状态的渲染

不要在 overlay 层渲染选中效果，而是在座位自身的状态层：

```typescript
// ❌ 旧方案：在 overlay 层绘制选中框
renderOverlay() {
  selectedSeats.forEach(seat => {
    drawSelectionBox(seat);
  });
}

// ✅ 新方案：切换座位自身的状态层
updateSeatState(seatId, 'selected') {
  const seat = findSeatElement(seatId);
  seat.querySelector('.normal-layer').style.display = 'none';
  seat.querySelector('.selected-layer').style.display = 'block';
}
```

---

## 九、总结

seats.io 的架构精髓：

1. **统一 transform**：所有元素共享一个 transform 根节点
2. **透明交互层**：扩大点击区域，不影响视觉
3. **状态分层**：预渲染多个状态层，通过 display 切换
4. **多层边框**：白色外边框 + 彩色内边框提高对比度
5. **world 坐标**：元素直接使用 world 坐标，不嵌套 transform

这些设计原则确保了：
- 性能优秀（减少 DOM 操作）
- 交互流畅（扩大点击区域）
- 视觉精致（多层效果）
- 架构清晰（单一 transform）
