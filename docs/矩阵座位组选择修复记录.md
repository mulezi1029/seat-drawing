# 矩阵座位组选择修复记录

## 问题描述

### 现象

使用矩阵工具绘制座位后，选择功能无法正常工作：

1. **单击选择失效**
   - 单击矩阵中的座位，只能选中单个座位
   - 无法像单排工具那样选中整组

2. **框选扩展失效**
   - 框选矩阵的部分座位，无法自动扩展为整个矩阵
   - 只选中框选范围内的座位

3. **Ctrl+单击失效**
   - Ctrl+单击无法切换整个矩阵的选中状态
   - 只能切换单个座位

### 影响范围

所有矩阵工具绘制的座位都受影响：
- ❌ 无法批量选中矩阵
- ❌ 无法批量移动矩阵
- ❌ 无法批量删除矩阵
- ❌ 无法批量旋转矩阵
- ❌ 无法批量编辑矩阵属性

### 用户体验问题

```
用户期望：
1. 绘制 5×10 的矩阵
2. 单击任意座位
3. 选中整个矩阵（50个座位）
4. 批量移动或删除

实际情况：
1. 绘制 5×10 的矩阵
2. 单击任意座位
3. 只选中 1 个座位 ❌
4. 需要框选所有 50 个座位才能操作
```

## 原因分析

### 座位ID格式差异

不同绘制工具生成的座位ID格式不同：

#### 单排工具
```typescript
// 生成逻辑
const groupId = `group-${Date.now()}`;
for (let i = 0; i < seatCount; i++) {
  seats.push({
    id: `seat-${groupId}-${i}`,
    // ...
  });
}

// 生成的 ID 示例
seat-group-1234567890-0
seat-group-1234567890-1
seat-group-1234567890-2
seat-group-1234567890-3
```

**格式特点**：
- 格式：`seat-{groupId}-{index}`
- 结尾：单个数字（座位索引）
- 示例：`seat-group-123-5`

#### 矩阵工具
```typescript
// 第一步：生成第一排
const groupId = `group-${Date.now()}`;
for (let i = 0; i < seatCount; i++) {
  firstRowSeats.push({
    id: `seat-${groupId}-0-${i}`,
    // ...
  });
}

// 第二步：生成其他行
for (let r = 1; r < rowCount; r++) {
  for (let c = 0; c < matrixFirstRow.length; c++) {
    allSeats.push({
      id: `seat-${groupId}-${r}-${c}`,
      // ...
    });
  }
}

// 生成的 ID 示例
seat-group-1234567890-0-0  // 第0行第0列
seat-group-1234567890-0-1  // 第0行第1列
seat-group-1234567890-1-0  // 第1行第0列
seat-group-1234567890-1-1  // 第1行第1列
```

**格式特点**：
- 格式：`seat-{groupId}-{row}-{col}`
- 结尾：两个数字（行索引和列索引）
- 示例：`seat-group-123-2-5`

### 正则表达式不匹配

原有的 `getGroupId` 函数：

```typescript
const getGroupId = useCallback((seatId: string): string | null => {
  const groupMatch = seatId.match(/^seat-(group-\d+)-\d+$/);
  return groupMatch ? groupMatch[1] : null;
}, []);
```

**正则表达式分析**：
```
/^seat-(group-\d+)-\d+$/

^           - 字符串开头
seat-       - 字面量 "seat-"
(group-\d+) - 捕获组：group- 后跟一个或多个数字
-           - 字面量 "-"
\d+         - 一个或多个数字
$           - 字符串结尾
```

**匹配测试**：

| 座位 ID | 正则匹配 | 结果 |
|---------|---------|------|
| `seat-group-123-0` | ✅ 匹配 | 返回 `group-123` |
| `seat-group-123-5` | ✅ 匹配 | 返回 `group-123` |
| `seat-group-456-0-0` | ❌ 不匹配 | 返回 `null` |
| `seat-group-456-2-5` | ❌ 不匹配 | 返回 `null` |

**问题根源**：

正则表达式 `/^seat-(group-\d+)-\d+$/` 要求字符串以**单个数字**结尾（`\d+$`），因此：
- ✅ 可以匹配单排格式：`seat-group-123-5`（以 `5` 结尾）
- ❌ 无法匹配矩阵格式：`seat-group-456-2-5`（以 `2-5` 结尾）

### 连锁反应

由于 `getGroupId` 返回 `null`，导致：

1. **`handleSeatClick` 失效**
```typescript
const groupId = getGroupId(seatId);  // 返回 null
const groupSeatIds = groupId ? getGroupSeatIds(groupId) : [seatId];
// groupSeatIds 只包含当前座位，无法获取整组
```

2. **`expandToGroups` 失效**
```typescript
const groupId = getGroupId(seatId);  // 返回 null
if (groupId) {
  groupIds.add(groupId);  // 不执行
} else {
  allSelectedIds.add(seatId);  // 只添加单个座位
}
```

3. **所有组操作失效**
- 单击选择：只选中单个座位
- 框选扩展：无法扩展为整组
- Ctrl+单击：无法切换整组
- 批量操作：无法操作整组

## 解决方案

### 修复正则表达式

修改 `getGroupId` 函数，支持两种ID格式：

```typescript
const getGroupId = useCallback((seatId: string): string | null => {
  // 修复前：只匹配单排格式
  // const groupMatch = seatId.match(/^seat-(group-\d+)-\d+$/);
  
  // 修复后：同时支持单排和矩阵格式
  const groupMatch = seatId.match(/^seat-(group-\d+)-/);
  
  return groupMatch ? groupMatch[1] : null;
}, []);
```

**新正则表达式分析**：
```
/^seat-(group-\d+)-/

^           - 字符串开头
seat-       - 字面量 "seat-"
(group-\d+) - 捕获组：group- 后跟一个或多个数字
-           - 字面量 "-"
            - 后面可以是任意内容（不限制）
```

**关键改动**：
- 移除了结尾的 `\d+$` 限制
- 只要求匹配到 `seat-{groupId}-` 部分
- 后面的内容（单个数字或多个数字）不做限制

### 验证测试

修复后的匹配测试：

| 座位 ID | 正则匹配 | 提取的组 ID |
|---------|---------|-----------|
| `seat-group-123-0` | ✅ 匹配 | `group-123` |
| `seat-group-123-5` | ✅ 匹配 | `group-123` |
| `seat-group-456-0-0` | ✅ 匹配 | `group-456` |
| `seat-group-456-2-5` | ✅ 匹配 | `group-456` |

**测试代码**：
```typescript
// 单排工具座位
console.log(getGroupId('seat-group-123-0'));    // 'group-123'
console.log(getGroupId('seat-group-123-5'));    // 'group-123'

// 矩阵工具座位
console.log(getGroupId('seat-group-456-0-0'));  // 'group-456'
console.log(getGroupId('seat-group-456-2-5'));  // 'group-456'

// 验证组选择
const matrixSeats = [
  { id: 'seat-group-456-0-0' },
  { id: 'seat-group-456-0-1' },
  { id: 'seat-group-456-1-0' },
  { id: 'seat-group-456-1-1' },
];

const groupId = getGroupId('seat-group-456-0-0');  // 'group-456'
const groupSeats = matrixSeats.filter(s => s.id.includes(groupId));
console.log(groupSeats.length);  // 4 ✅
```

## 修改的文件

### `app/src/components/section-edit/EditModeCanvas.tsx`

**修改位置**：第 140-143 行

**修改前**：
```typescript
const getGroupId = useCallback((seatId: string): string | null => {
  const groupMatch = seatId.match(/^seat-(group-\d+)-\d+$/);
  return groupMatch ? groupMatch[1] : null;
}, []);
```

**修改后**：
```typescript
const getGroupId = useCallback((seatId: string): string | null => {
  // 匹配单排格式: seat-group-123-0
  // 匹配矩阵格式: seat-group-123-0-1
  const groupMatch = seatId.match(/^seat-(group-\d+)-/);
  return groupMatch ? groupMatch[1] : null;
}, []);
```

## 影响范围

### 修复的功能

修复后，以下功能恢复正常：

1. **单击选择**
   - ✅ 单击矩阵中任意座位 → 选中整个矩阵
   - ✅ 单击单排中任意座位 → 选中整排（保持原有功能）

2. **框选扩展**
   - ✅ 框选矩阵部分座位 → 自动扩展为整个矩阵
   - ✅ 框选单排部分座位 → 自动扩展为整排（保持原有功能）

3. **Ctrl+单击**
   - ✅ Ctrl+单击矩阵座位 → 切换整个矩阵的选中状态
   - ✅ Ctrl+单击单排座位 → 切换整排的选中状态（保持原有功能）

4. **批量操作**
   - ✅ 删除矩阵座位 → 删除整个矩阵
   - ✅ 拖拽矩阵座位 → 移动整个矩阵
   - ✅ 旋转矩阵座位 → 旋转整个矩阵
   - ✅ 编辑矩阵属性 → 批量修改整个矩阵

### 兼容性

修复不影响现有功能：
- ✅ 单排工具的组选择功能正常
- ✅ 单个座位的选择功能正常
- ✅ 所有选择相关的快捷键正常
- ✅ 所有批量操作功能正常

## 验证步骤

### 测试场景 1：单击选择矩阵

```
1. 按 2 切换到矩阵工具
2. 绘制 3×5 的矩阵（15个座位）
3. 按 V 切换到选择工具
4. 单击矩阵中的任意座位
5. ✅ 验证：所有 15 个座位都被选中（蓝色边框）
```

### 测试场景 2：框选扩展矩阵

```
1. 绘制 4×6 的矩阵（24个座位）
2. 按 V 切换到选择工具
3. 框选只覆盖左上角 2×2 区域（4个座位）
4. ✅ 验证：整个矩阵 24 个座位都被选中
```

### 测试场景 3：Ctrl+单击切换矩阵

```
1. 绘制两个矩阵：矩阵A（3×3）和矩阵B（2×4）
2. 单击矩阵A → 选中矩阵A
3. Ctrl+单击矩阵B → 添加矩阵B到选择
4. ✅ 验证：两个矩阵都被选中（共 17 个座位）
5. Ctrl+单击矩阵A → 取消矩阵A
6. ✅ 验证：只有矩阵B被选中（8 个座位）
```

### 测试场景 4：批量删除矩阵

```
1. 绘制 5×8 的矩阵（40个座位）
2. 单击选中矩阵
3. 按 Delete 键
4. ✅ 验证：整个矩阵被删除（40个座位全部消失）
```

### 测试场景 5：批量移动矩阵

```
1. 绘制 3×4 的矩阵
2. 单击选中矩阵
3. 拖拽任意座位移动
4. ✅ 验证：整个矩阵一起移动（12个座位保持相对位置）
```

### 测试场景 6：批量旋转矩阵

```
1. 绘制 4×5 的矩阵
2. 单击选中矩阵
3. 拖拽旋转手柄
4. ✅ 验证：整个矩阵一起旋转（20个座位保持矩阵结构）
```

### 测试场景 7：单排工具兼容性

```
1. 按 1 切换到单排工具
2. 绘制一排 8 个座位
3. 按 V 切换到选择工具
4. 单击任意座位
5. ✅ 验证：整排 8 个座位都被选中（保持原有功能）
```

## 技术要点

### 1. 正则表达式设计

**原则**：
- 尽可能宽松，支持多种格式
- 只捕获必要的部分（组ID）
- 避免过度限制结尾格式

**对比**：
```typescript
// 严格匹配（修复前）
/^seat-(group-\d+)-\d+$/
// 优点：精确匹配单排格式
// 缺点：无法匹配矩阵格式

// 宽松匹配（修复后）
/^seat-(group-\d+)-/
// 优点：同时支持单排和矩阵格式
// 缺点：可能匹配到非预期格式（但实际不会出现）
```

### 2. ID格式设计建议

**当前格式**：
- 单排：`seat-{groupId}-{index}`
- 矩阵：`seat-{groupId}-{row}-{col}`

**优点**：
- 包含位置信息（行列索引）
- 便于调试和追踪

**改进建议**：

如果未来需要更多工具，可以考虑统一格式：
```typescript
// 方案 1：统一使用单索引
seat-{groupId}-{globalIndex}

// 方案 2：添加类型前缀
seat-row-{groupId}-{index}
seat-matrix-{groupId}-{row}-{col}
seat-arc-{groupId}-{index}

// 方案 3：使用分隔符
seat:{groupId}:{index}
seat:{groupId}:{row}:{col}
```

### 3. 组ID提取策略

**当前策略**：
```typescript
// 使用正则表达式提取
const groupMatch = seatId.match(/^seat-(group-\d+)-/);
return groupMatch ? groupMatch[1] : null;
```

**替代方案**：
```typescript
// 方案 1：字符串分割
const parts = seatId.split('-');
if (parts.length >= 3 && parts[0] === 'seat' && parts[1] === 'group') {
  return `${parts[1]}-${parts[2]}`;
}

// 方案 2：固定位置提取
if (seatId.startsWith('seat-group-')) {
  const afterPrefix = seatId.substring(11);  // 'seat-group-'.length
  const nextDash = afterPrefix.indexOf('-');
  return `group-${afterPrefix.substring(0, nextDash)}`;
}
```

**选择理由**：
- 正则表达式更清晰、更易维护
- 性能差异可忽略（座位数量有限）
- 便于未来扩展和修改

## 经验总结

### 1. ID格式设计要考虑扩展性

**问题**：
- 初期只考虑单排工具，使用简单的ID格式
- 后续添加矩阵工具时，改变了ID格式
- 导致现有的解析逻辑失效

**教训**：
- 设计ID格式时要考虑未来的扩展
- 解析逻辑要足够灵活，支持多种格式
- 或者统一所有工具的ID格式

### 2. 正则表达式不要过度限制

**问题**：
- 原有正则表达式过于严格，限制了结尾格式
- 导致无法匹配新的ID格式

**教训**：
- 正则表达式应该只捕获必要的部分
- 避免对不关心的部分做过多限制
- 定期review正则表达式的适用性

### 3. 测试要覆盖所有工具

**问题**：
- 矩阵工具实现后，没有充分测试组选择功能
- 导致问题在用户使用时才被发现

**教训**：
- 新功能实现后要全面测试
- 特别是与现有功能的集成测试
- 建立自动化测试用例

### 4. 文档要及时更新

**问题**：
- ID格式变化后，没有及时更新文档
- 导致后续开发时不清楚格式差异

**教训**：
- 关键设计变更要及时记录
- 维护清晰的技术文档
- 包括ID格式、正则表达式等细节

## 总结

这次修复解决了矩阵座位组选择失效的问题，核心是修改了 `getGroupId` 函数的正则表达式，使其能够同时支持单排和矩阵两种ID格式。

**修复效果**：
- ✅ 矩阵座位可以正常组选择
- ✅ 单排座位功能保持不变
- ✅ 所有批量操作恢复正常
- ✅ 用户体验显著提升

**技术收获**：
- ID格式设计要考虑扩展性
- 正则表达式不要过度限制
- 测试要覆盖所有场景
- 文档要及时更新

这是一个典型的"小改动，大影响"的案例，一行代码的修改解决了整个矩阵工具的选择问题。
